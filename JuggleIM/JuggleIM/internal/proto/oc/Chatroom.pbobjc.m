// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: chatroom.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Chatroom.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(BatchBanUserReq);
GPBObjCClassDeclaration(ChatAttBatchReq);
GPBObjCClassDeclaration(ChatAttBatchResp);
GPBObjCClassDeclaration(ChatAttItem);
GPBObjCClassDeclaration(ChatAttReq);
GPBObjCClassDeclaration(ChatAttResp);
GPBObjCClassDeclaration(ChatAtts);
GPBObjCClassDeclaration(ChatMembersDispatchReq);
GPBObjCClassDeclaration(ChatMsgNode);
GPBObjCClassDeclaration(ChatroomEvents);
GPBObjCClassDeclaration(ChatroomInfo);
GPBObjCClassDeclaration(ChatroomMember);
GPBObjCClassDeclaration(ChatroomReq);
GPBObjCClassDeclaration(ChrmBanMember);
GPBObjCClassDeclaration(ChrmDispatchReq);
GPBObjCClassDeclaration(ChrmEvent);
GPBObjCClassDeclaration(DownMsg);
GPBObjCClassDeclaration(QryChatroomReq);
GPBObjCClassDeclaration(QryChrmBanUsersReq);
GPBObjCClassDeclaration(QryChrmBanUsersResp);
GPBObjCClassDeclaration(SyncChatroomAttResp);
GPBObjCClassDeclaration(SyncChatroomEventResp);
GPBObjCClassDeclaration(SyncChatroomMsgResp);
GPBObjCClassDeclaration(SyncChatroomReq);
GPBObjCClassDeclaration(UpMsg);

#pragma mark - ChatroomRoot

@implementation ChatroomRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription ChatroomRoot_FileDescription = {
  .package = NULL,
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum ChrmEventType

GPBEnumDescriptor *ChrmEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Join\000Quit\000Kick\000Fallout\000";
    static const int32_t values[] = {
        ChrmEventType_Join,
        ChrmEventType_Quit,
        ChrmEventType_Kick,
        ChrmEventType_Fallout,
    };
    static const char *extraTextFormatInfo = "\004\000\004\000\001\004\000\002\004\000\003\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChrmEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChrmEventType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChrmEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChrmEventType_Join:
    case ChrmEventType_Quit:
    case ChrmEventType_Kick:
    case ChrmEventType_Fallout:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChrmDispatchType

GPBEnumDescriptor *ChrmDispatchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "CreateChatroom\000DestroyChatroom\000";
    static const int32_t values[] = {
        ChrmDispatchType_CreateChatroom,
        ChrmDispatchType_DestroyChatroom,
    };
    static const char *extraTextFormatInfo = "\002\000\016\000\001\017\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChrmDispatchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChrmDispatchType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChrmDispatchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChrmDispatchType_CreateChatroom:
    case ChrmDispatchType_DestroyChatroom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatMembersDispatchType

GPBEnumDescriptor *ChatMembersDispatchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DispatchDefault\000JoinChatroom\000QuitChatroo"
        "m\000";
    static const int32_t values[] = {
        ChatMembersDispatchType_DispatchDefault,
        ChatMembersDispatchType_JoinChatroom,
        ChatMembersDispatchType_QuitChatroom,
    };
    static const char *extraTextFormatInfo = "\003\000\017\000\001\014\000\002\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatMembersDispatchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatMembersDispatchType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatMembersDispatchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatMembersDispatchType_DispatchDefault:
    case ChatMembersDispatchType_JoinChatroom:
    case ChatMembersDispatchType_QuitChatroom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatAttOptType

GPBEnumDescriptor *ChatAttOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ChatAttOptDefault\000ChatAttOptAdd\000ChatAttO"
        "ptDel\000";
    static const int32_t values[] = {
        ChatAttOptType_ChatAttOptDefault,
        ChatAttOptType_ChatAttOptAdd,
        ChatAttOptType_ChatAttOptDel,
    };
    static const char *extraTextFormatInfo = "\003\000\n\207\000\001\n\203\000\002\n\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatAttOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatAttOptType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatAttOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatAttOptType_ChatAttOptDefault:
    case ChatAttOptType_ChatAttOptAdd:
    case ChatAttOptType_ChatAttOptDel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChrmBanType

GPBEnumDescriptor *ChrmBanType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ChrmBanTypeDefault\000Ban\000Mute\000Allow\000";
    static const int32_t values[] = {
        ChrmBanType_ChrmBanTypeDefault,
        ChrmBanType_Ban,
        ChrmBanType_Mute,
        ChrmBanType_Allow,
    };
    static const char *extraTextFormatInfo = "\004\000\013\207\000\001\003\000\002\004\000\003\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChrmBanType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChrmBanType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChrmBanType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChrmBanType_ChrmBanTypeDefault:
    case ChrmBanType_Ban:
    case ChrmBanType_Mute:
    case ChrmBanType_Allow:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SyncChatroomReq

@implementation SyncChatroomReq

@dynamic chatroomId;
@dynamic syncTime;
@dynamic count;

typedef struct SyncChatroomReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSString *chatroomId;
  int64_t syncTime;
} SyncChatroomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_ChatroomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_SyncTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomReq)
                                   messageName:@"SyncChatroomReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\n\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomMsgResp

@implementation SyncChatroomMsgResp

@dynamic msgsArray, msgsArray_Count;

typedef struct SyncChatroomMsgResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
} SyncChatroomMsgResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = SyncChatroomMsgResp_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncChatroomMsgResp__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomMsgResp)
                                   messageName:@"SyncChatroomMsgResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomMsgResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomAttResp

@implementation SyncChatroomAttResp

@dynamic attsArray, attsArray_Count;

typedef struct SyncChatroomAttResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attsArray;
} SyncChatroomAttResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = SyncChatroomAttResp_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncChatroomAttResp__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomAttResp)
                                   messageName:@"SyncChatroomAttResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomAttResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomEventResp

@implementation SyncChatroomEventResp

@dynamic chrmEventsArray, chrmEventsArray_Count;

typedef struct SyncChatroomEventResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chrmEventsArray;
} SyncChatroomEventResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chrmEventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChrmEvent),
        .number = SyncChatroomEventResp_FieldNumber_ChrmEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncChatroomEventResp__storage_, chrmEventsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomEventResp)
                                   messageName:@"SyncChatroomEventResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomEventResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000chrmEvents\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomEvents

@implementation ChatroomEvents

@dynamic chatId;
@dynamic eventsArray, eventsArray_Count;

typedef struct ChatroomEvents__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSMutableArray *eventsArray;
} ChatroomEvents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomEvents_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomEvents__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChrmEvent),
        .number = ChatroomEvents_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatroomEvents__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomEvents)
                                   messageName:@"ChatroomEvents"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomEvents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChrmEvent

@implementation ChrmEvent

@dynamic eventType;
@dynamic chatId;
@dynamic userId;
@dynamic eventTime;

typedef struct ChrmEvent__storage_ {
  uint32_t _has_storage_[1];
  ChrmEventType eventType;
  NSString *chatId;
  NSString *userId;
  int64_t eventTime;
} ChrmEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.enumDescFunc = ChrmEventType_EnumDescriptor,
        .number = ChrmEvent_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_ChatId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_EventTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, eventTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChrmEvent)
                                   messageName:@"ChrmEvent"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChrmEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\t\000\002\006\000\003\006\000\004\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChrmEvent_EventType_RawValue(ChrmEvent *message) {
  GPBDescriptor *descriptor = [ChrmEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmEvent_FieldNumber_EventType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChrmEvent_EventType_RawValue(ChrmEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [ChrmEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmEvent_FieldNumber_EventType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryChatroomReq

@implementation QryChatroomReq

@dynamic chatId;
@dynamic withMembers;
@dynamic count;
@dynamic order;
@dynamic withAtts;
@dynamic attKeysArray, attKeysArray_Count;

typedef struct QryChatroomReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  NSString *chatId;
  NSMutableArray *attKeysArray;
} QryChatroomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryChatroomReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withMembers",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_WithMembers,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryChatroomReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_Order,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryChatroomReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "withAtts",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_WithAtts,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "attKeysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomReq_FieldNumber_AttKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryChatroomReq__storage_, attKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryChatroomReq)
                                   messageName:@"QryChatroomReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryChatroomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\006\000\002\013\000\005\010\000\006\000attKeys\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomReq

@implementation ChatroomReq

@dynamic chatId;
@dynamic chatName;
@dynamic isAutoCreate;

typedef struct ChatroomReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSString *chatName;
} ChatroomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomReq_FieldNumber_ChatName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatroomReq__storage_, chatName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAutoCreate",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomReq_FieldNumber_IsAutoCreate,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomReq)
                                   messageName:@"ChatroomReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\002\010\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomInfo

@implementation ChatroomInfo

@dynamic chatId;
@dynamic chatName;
@dynamic membersArray, membersArray_Count;
@dynamic attsArray, attsArray_Count;
@dynamic memberCount;
@dynamic isMute;

typedef struct ChatroomInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberCount;
  NSString *chatId;
  NSString *chatName;
  NSMutableArray *membersArray;
  NSMutableArray *attsArray;
} ChatroomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_ChatName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, chatName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatroomMember),
        .number = ChatroomInfo_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = ChatroomInfo_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_MemberCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_IsMute,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomInfo)
                                   messageName:@"ChatroomInfo"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\006\000\002\010\000\005\013\000\006\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMsgNode

@implementation ChatMsgNode

@dynamic nodeName;
@dynamic method;

typedef struct ChatMsgNode__storage_ {
  uint32_t _has_storage_[1];
  NSString *nodeName;
  NSString *method;
} ChatMsgNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMsgNode_FieldNumber_NodeName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMsgNode__storage_, nodeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMsgNode_FieldNumber_Method,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMsgNode__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatMsgNode)
                                   messageName:@"ChatMsgNode"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMsgNode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomMember

@implementation ChatroomMember

@dynamic memberId;
@dynamic memberName;
@dynamic addedTime;

typedef struct ChatroomMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
  NSString *memberName;
  int64_t addedTime;
} ChatroomMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_MemberName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_AddedTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, addedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomMember)
                                   messageName:@"ChatroomMember"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\n\000\003\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChrmDispatchReq

@implementation ChrmDispatchReq

@dynamic chatId;
@dynamic dispatchType;

typedef struct ChrmDispatchReq__storage_ {
  uint32_t _has_storage_[1];
  ChrmDispatchType dispatchType;
  NSString *chatId;
} ChrmDispatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmDispatchReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChrmDispatchReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dispatchType",
        .dataTypeSpecific.enumDescFunc = ChrmDispatchType_EnumDescriptor,
        .number = ChrmDispatchReq_FieldNumber_DispatchType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChrmDispatchReq__storage_, dispatchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChrmDispatchReq)
                                   messageName:@"ChrmDispatchReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChrmDispatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChrmDispatchReq_DispatchType_RawValue(ChrmDispatchReq *message) {
  GPBDescriptor *descriptor = [ChrmDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmDispatchReq_FieldNumber_DispatchType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChrmDispatchReq_DispatchType_RawValue(ChrmDispatchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ChrmDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmDispatchReq_FieldNumber_DispatchType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatMembersDispatchReq

@implementation ChatMembersDispatchReq

@dynamic chatId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic dispatchType;

typedef struct ChatMembersDispatchReq__storage_ {
  uint32_t _has_storage_[1];
  ChatMembersDispatchType dispatchType;
  NSString *chatId;
  NSMutableArray *memberIdsArray;
} ChatMembersDispatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dispatchType",
        .dataTypeSpecific.enumDescFunc = ChatMembersDispatchType_EnumDescriptor,
        .number = ChatMembersDispatchReq_FieldNumber_DispatchType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, dispatchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatMembersDispatchReq)
                                   messageName:@"ChatMembersDispatchReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMembersDispatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\002\000memberIds\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAttReq

@implementation ChatAttReq

@dynamic key;
@dynamic value;
@dynamic isForce;
@dynamic isAutoDel;
@dynamic hasMsg, msg;

typedef struct ChatAttReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
  UpMsg *msg;
} ChatAttReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isForce",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_IsForce,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAutoDel",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_IsAutoDel,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(UpMsg),
        .number = ChatAttReq_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttReq)
                                   messageName:@"ChatAttReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\003\007\000\004\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttResp

@implementation ChatAttResp

@dynamic key;
@dynamic code;
@dynamic attTime;
@dynamic msgCode;
@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeq;

typedef struct ChatAttResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t msgCode;
  NSString *key;
  NSString *msgId;
  int64_t attTime;
  int64_t msgTime;
  int64_t msgSeq;
} ChatAttResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_AttTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, attTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgSeq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttResp)
                                   messageName:@"ChatAttResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\003\007\000\013\007\000\014\005\000\r\007\000\016\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttBatchReq

@implementation ChatAttBatchReq

@dynamic attsArray, attsArray_Count;

typedef struct ChatAttBatchReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attsArray;
} ChatAttBatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttReq),
        .number = ChatAttBatchReq_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAttBatchReq__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttBatchReq)
                                   messageName:@"ChatAttBatchReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttBatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttBatchResp

@implementation ChatAttBatchResp

@dynamic attRespsArray, attRespsArray_Count;

typedef struct ChatAttBatchResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attRespsArray;
} ChatAttBatchResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attRespsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttResp),
        .number = ChatAttBatchResp_FieldNumber_AttRespsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAttBatchResp__storage_, attRespsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttBatchResp)
                                   messageName:@"ChatAttBatchResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttBatchResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000attResps\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttItem

@implementation ChatAttItem

@dynamic key;
@dynamic value;
@dynamic attTime;
@dynamic userId;
@dynamic optType;

typedef struct ChatAttItem__storage_ {
  uint32_t _has_storage_[1];
  ChatAttOptType optType;
  NSString *key;
  NSString *value;
  NSString *userId;
  int64_t attTime;
} ChatAttItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_AttTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, attTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "optType",
        .dataTypeSpecific.enumDescFunc = ChatAttOptType_EnumDescriptor,
        .number = ChatAttItem_FieldNumber_OptType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, optType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttItem)
                                   messageName:@"ChatAttItem"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\003\007\000\004\006\000\005\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatAttItem_OptType_RawValue(ChatAttItem *message) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatAttItem_OptType_RawValue(ChatAttItem *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAtts

@implementation ChatAtts

@dynamic chatId;
@dynamic attsArray, attsArray_Count;
@dynamic isComplete;
@dynamic isFinished;

typedef struct ChatAtts__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSMutableArray *attsArray;
} ChatAtts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = ChatAtts_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isComplete",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsComplete,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsFinished,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAtts)
                                   messageName:@"ChatAtts"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAtts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\003\n\000\004\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchBanUserReq

@implementation BatchBanUserReq

@dynamic chatId;
@dynamic banType;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic endTime;
@dynamic isDelete;

typedef struct BatchBanUserReq__storage_ {
  uint32_t _has_storage_[1];
  ChrmBanType banType;
  NSString *chatId;
  NSMutableArray *memberIdsArray;
  int64_t endTime;
} BatchBanUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = BatchBanUserReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchBanUserReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = ChrmBanType_EnumDescriptor,
        .number = BatchBanUserReq_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchBanUserReq__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BatchBanUserReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchBanUserReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BatchBanUserReq_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BatchBanUserReq__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isDelete",
        .dataTypeSpecific.clazz = Nil,
        .number = BatchBanUserReq_FieldNumber_IsDelete,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BatchBanUserReq)
                                   messageName:@"BatchBanUserReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchBanUserReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\006\000\002\007\000\003\000memberIds\000\004\007\000\005\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BatchBanUserReq_BanType_RawValue(BatchBanUserReq *message) {
  GPBDescriptor *descriptor = [BatchBanUserReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BatchBanUserReq_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBatchBanUserReq_BanType_RawValue(BatchBanUserReq *message, int32_t value) {
  GPBDescriptor *descriptor = [BatchBanUserReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BatchBanUserReq_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryChrmBanUsersReq

@implementation QryChrmBanUsersReq

@dynamic chatId;
@dynamic banType;
@dynamic offset;
@dynamic limit;

typedef struct QryChrmBanUsersReq__storage_ {
  uint32_t _has_storage_[1];
  ChrmBanType banType;
  NSString *chatId;
  NSString *offset;
  int64_t limit;
} QryChrmBanUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChrmBanUsersReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryChrmBanUsersReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = ChrmBanType_EnumDescriptor,
        .number = QryChrmBanUsersReq_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryChrmBanUsersReq__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChrmBanUsersReq_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryChrmBanUsersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChrmBanUsersReq_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryChrmBanUsersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryChrmBanUsersReq)
                                   messageName:@"QryChrmBanUsersReq"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryChrmBanUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryChrmBanUsersReq_BanType_RawValue(QryChrmBanUsersReq *message) {
  GPBDescriptor *descriptor = [QryChrmBanUsersReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryChrmBanUsersReq_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryChrmBanUsersReq_BanType_RawValue(QryChrmBanUsersReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryChrmBanUsersReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryChrmBanUsersReq_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryChrmBanUsersResp

@implementation QryChrmBanUsersResp

@dynamic chatId;
@dynamic banType;
@dynamic membersArray, membersArray_Count;
@dynamic offset;

typedef struct QryChrmBanUsersResp__storage_ {
  uint32_t _has_storage_[1];
  ChrmBanType banType;
  NSString *chatId;
  NSMutableArray *membersArray;
  NSString *offset;
} QryChrmBanUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChrmBanUsersResp_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryChrmBanUsersResp__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = ChrmBanType_EnumDescriptor,
        .number = QryChrmBanUsersResp_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryChrmBanUsersResp__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChrmBanMember),
        .number = QryChrmBanUsersResp_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryChrmBanUsersResp__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChrmBanUsersResp_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryChrmBanUsersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryChrmBanUsersResp)
                                   messageName:@"QryChrmBanUsersResp"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryChrmBanUsersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002G\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryChrmBanUsersResp_BanType_RawValue(QryChrmBanUsersResp *message) {
  GPBDescriptor *descriptor = [QryChrmBanUsersResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryChrmBanUsersResp_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryChrmBanUsersResp_BanType_RawValue(QryChrmBanUsersResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryChrmBanUsersResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryChrmBanUsersResp_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChrmBanMember

@implementation ChrmBanMember

@dynamic memberId;
@dynamic createdTime;
@dynamic endTime;

typedef struct ChrmBanMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
  int64_t createdTime;
  int64_t endTime;
} ChrmBanMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmBanMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChrmBanMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmBanMember_FieldNumber_CreatedTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChrmBanMember__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmBanMember_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChrmBanMember__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChrmBanMember)
                                   messageName:@"ChrmBanMember"
                               fileDescription:&ChatroomRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChrmBanMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
