// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: appmessages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Appmessages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AddGrpAssistantReq);
GPBObjCClassDeclaration(AddHisMsgReq);
GPBObjCClassDeclaration(AssistantMsgResp);
GPBObjCClassDeclaration(BanUser);
GPBObjCClassDeclaration(BanUsersReq);
GPBObjCClassDeclaration(BlockUser);
GPBObjCClassDeclaration(BlockUsersReq);
GPBObjCClassDeclaration(BusinessLog);
GPBObjCClassDeclaration(ChatAttBatchReq);
GPBObjCClassDeclaration(ChatAttBatchResp);
GPBObjCClassDeclaration(ChatAttItem);
GPBObjCClassDeclaration(ChatAttReq);
GPBObjCClassDeclaration(ChatAttResp);
GPBObjCClassDeclaration(ChatAtts);
GPBObjCClassDeclaration(ChatMembersDispatchReq);
GPBObjCClassDeclaration(ChatMsgNode);
GPBObjCClassDeclaration(ChatroomInfo);
GPBObjCClassDeclaration(ChatroomMember);
GPBObjCClassDeclaration(CheckGroupMembersReq);
GPBObjCClassDeclaration(CheckGroupMembersResp);
GPBObjCClassDeclaration(ChrmDispatchReq);
GPBObjCClassDeclaration(ChrmEvent);
GPBObjCClassDeclaration(CleanHisMsgReq);
GPBObjCClassDeclaration(ClearUnreadReq);
GPBObjCClassDeclaration(ConnectionLog);
GPBObjCClassDeclaration(ConverFilter);
GPBObjCClassDeclaration(Conversation);
GPBObjCClassDeclaration(ConversationsReq);
GPBObjCClassDeclaration(DelHisMsgsReq);
GPBObjCClassDeclaration(DisconnectionLog);
GPBObjCClassDeclaration(DownMsg);
GPBObjCClassDeclaration(DownMsgSet);
GPBObjCClassDeclaration(GlobalConver);
GPBObjCClassDeclaration(GroupIdsReq);
GPBObjCClassDeclaration(GroupInfo);
GPBObjCClassDeclaration(GroupInfoReq);
GPBObjCClassDeclaration(GroupInfosResp);
GPBObjCClassDeclaration(GroupMember);
GPBObjCClassDeclaration(GroupMemberAllowReq);
GPBObjCClassDeclaration(GroupMemberMuteReq);
GPBObjCClassDeclaration(GroupMembersReq);
GPBObjCClassDeclaration(GroupMembersResp);
GPBObjCClassDeclaration(GroupMuteReq);
GPBObjCClassDeclaration(GroupSnapshot);
GPBObjCClassDeclaration(IndexScope);
GPBObjCClassDeclaration(KickUserReq);
GPBObjCClassDeclaration(KvItem);
GPBObjCClassDeclaration(LogEntity);
GPBObjCClassDeclaration(MarkGrpMsgReadReq);
GPBObjCClassDeclaration(MarkReadReq);
GPBObjCClassDeclaration(MemberReadDetailItem);
GPBObjCClassDeclaration(MentionInfo);
GPBObjCClassDeclaration(MentionMsg);
GPBObjCClassDeclaration(Mentions);
GPBObjCClassDeclaration(MergeMsgReq);
GPBObjCClassDeclaration(MergedMsgs);
GPBObjCClassDeclaration(ModifyMsgReq);
GPBObjCClassDeclaration(MsgExtItem);
GPBObjCClassDeclaration(Nil_Class);
GPBObjCClassDeclaration(Notify);
GPBObjCClassDeclaration(OnlineOfflineMsg);
GPBObjCClassDeclaration(OnlineStatus);
GPBObjCClassDeclaration(PreSignResp);
GPBObjCClassDeclaration(PushData);
GPBObjCClassDeclaration(PushSwitch);
GPBObjCClassDeclaration(QiNiuCredResp);
GPBObjCClassDeclaration(QryBanUsersReq);
GPBObjCClassDeclaration(QryBanUsersResp);
GPBObjCClassDeclaration(QryBlockUsersReq);
GPBObjCClassDeclaration(QryBlockUsersResp);
GPBObjCClassDeclaration(QryChatroomMembersReq);
GPBObjCClassDeclaration(QryConverReq);
GPBObjCClassDeclaration(QryConverResp);
GPBObjCClassDeclaration(QryConversationsReq);
GPBObjCClassDeclaration(QryConversationsResp);
GPBObjCClassDeclaration(QryFileCredReq);
GPBObjCClassDeclaration(QryFileCredResp);
GPBObjCClassDeclaration(QryFirstUnreadMsgReq);
GPBObjCClassDeclaration(QryGlobalConversReq);
GPBObjCClassDeclaration(QryGlobalConversResp);
GPBObjCClassDeclaration(QryGroupMembersReq);
GPBObjCClassDeclaration(QryGrpMemberSettingsReq);
GPBObjCClassDeclaration(QryGrpMemberSettingsResp);
GPBObjCClassDeclaration(QryGrpSnapshotReq);
GPBObjCClassDeclaration(QryHisMsgByIdsReq);
GPBObjCClassDeclaration(QryHisMsgsReq);
GPBObjCClassDeclaration(QryLatestMsgReq);
GPBObjCClassDeclaration(QryLatestMsgResp);
GPBObjCClassDeclaration(QryMentionMsgsReq);
GPBObjCClassDeclaration(QryMentionMsgsResp);
GPBObjCClassDeclaration(QryMergedMsgsReq);
GPBObjCClassDeclaration(QryReadDetailReq);
GPBObjCClassDeclaration(QryReadDetailResp);
GPBObjCClassDeclaration(QryReadInfosReq);
GPBObjCClassDeclaration(QryReadInfosResp);
GPBObjCClassDeclaration(QryTopConversReq);
GPBObjCClassDeclaration(QryTotalUnreadCountReq);
GPBObjCClassDeclaration(QryTotalUnreadCountResp);
GPBObjCClassDeclaration(ReadInfoItem);
GPBObjCClassDeclaration(RecallMsgReq);
GPBObjCClassDeclaration(RpcMessageWraper);
GPBObjCClassDeclaration(SdkRequestLog);
GPBObjCClassDeclaration(SdkResponseLog);
GPBObjCClassDeclaration(SimpleConversation);
GPBObjCClassDeclaration(SimpleMsg);
GPBObjCClassDeclaration(SyncChatroomAttResp);
GPBObjCClassDeclaration(SyncChatroomMsgResp);
GPBObjCClassDeclaration(SyncChatroomReq);
GPBObjCClassDeclaration(SyncChatroomResp);
GPBObjCClassDeclaration(SyncConversationsReq);
GPBObjCClassDeclaration(SyncMsgReq);
GPBObjCClassDeclaration(TopConversResp);
GPBObjCClassDeclaration(UndisturbConverItem);
GPBObjCClassDeclaration(UndisturbConversReq);
GPBObjCClassDeclaration(UpMsg);
GPBObjCClassDeclaration(UpdLatestMsgReq);
GPBObjCClassDeclaration(UploadLogStatusReq);
GPBObjCClassDeclaration(UserIdReq);
GPBObjCClassDeclaration(UserIdsReq);
GPBObjCClassDeclaration(UserInfo);
GPBObjCClassDeclaration(UserInfos);
GPBObjCClassDeclaration(UserInfosResp);
GPBObjCClassDeclaration(UserOnlineItem);
GPBObjCClassDeclaration(UserOnlineStatusReq);
GPBObjCClassDeclaration(UserOnlineStatusResp);
GPBObjCClassDeclaration(UserRegResp);
GPBObjCClassDeclaration(UserUndisturb);
GPBObjCClassDeclaration(UserUndisturbItem);

#pragma mark - AppmessagesRoot

@implementation AppmessagesRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription AppmessagesRoot_FileDescription = {
  .package = NULL,
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum RpcMsgType

GPBEnumDescriptor *RpcMsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "UserPub\000UserPubAck\000ServerPub\000ServerPubAc"
        "k\000QueryMsg\000QueryAck\000QueryConfirm\000";
    static const int32_t values[] = {
        RpcMsgType_UserPub,
        RpcMsgType_UserPubAck,
        RpcMsgType_ServerPub,
        RpcMsgType_ServerPubAck,
        RpcMsgType_QueryMsg,
        RpcMsgType_QueryAck,
        RpcMsgType_QueryConfirm,
    };
    static const char *extraTextFormatInfo = "\007\000\007\000\001\n\000\002\t\000\003\014\000\004\010\000\005\010\000\006\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RpcMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RpcMsgType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RpcMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RpcMsgType_UserPub:
    case RpcMsgType_UserPubAck:
    case RpcMsgType_ServerPub:
    case RpcMsgType_ServerPubAck:
    case RpcMsgType_QueryMsg:
    case RpcMsgType_QueryAck:
    case RpcMsgType_QueryConfirm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MentionType

GPBEnumDescriptor *MentionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "MentionDefault\000All\000Someone\000AllAndSomeone"
        "\000";
    static const int32_t values[] = {
        MentionType_MentionDefault,
        MentionType_All,
        MentionType_Someone,
        MentionType_AllAndSomeone,
    };
    static const char *extraTextFormatInfo = "\004\000\016\000\001\003\000\002\007\000\003\r\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MentionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MentionType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MentionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MentionType_MentionDefault:
    case MentionType_All:
    case MentionType_Someone:
    case MentionType_AllAndSomeone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChannelType

GPBEnumDescriptor *ChannelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Private\000Group\000Chatroom\000System\000Gr"
        "oupCast\000BroadCast\000";
    static const int32_t values[] = {
        ChannelType_Unknown,
        ChannelType_Private,
        ChannelType_Group,
        ChannelType_Chatroom,
        ChannelType_System,
        ChannelType_GroupCast,
        ChannelType_BroadCast,
    };
    static const char *extraTextFormatInfo = "\007\000\007\000\001\007\000\002\005\000\003\010\000\004\006\000\005\t\000\006\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelType_Unknown:
    case ChannelType_Private:
    case ChannelType_Group:
    case ChannelType_Chatroom:
    case ChannelType_System:
    case ChannelType_GroupCast:
    case ChannelType_BroadCast:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum NotifyType

GPBEnumDescriptor *NotifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Default\000Msg\000ChatroomMsg\000ChatroomAtt\000Chat"
        "roomEvent\000ChatroomDestroy\000";
    static const int32_t values[] = {
        NotifyType_Default,
        NotifyType_Msg,
        NotifyType_ChatroomMsg,
        NotifyType_ChatroomAtt,
        NotifyType_ChatroomEvent,
        NotifyType_ChatroomDestroy,
    };
    static const char *extraTextFormatInfo = "\006\000\007\000\001\003\000\002\013\000\003\013\000\004\r\000\005\017\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NotifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NotifyType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NotifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NotifyType_Default:
    case NotifyType_Msg:
    case NotifyType_ChatroomMsg:
    case NotifyType_ChatroomAtt:
    case NotifyType_ChatroomEvent:
    case NotifyType_ChatroomDestroy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UpdLatestMsgAction

GPBEnumDescriptor *UpdLatestMsgAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "UpdMsg\000UpdRead\000";
    static const int32_t values[] = {
        UpdLatestMsgAction_UpdMsg,
        UpdLatestMsgAction_UpdRead,
    };
    static const char *extraTextFormatInfo = "\002\000\006\000\001\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpdLatestMsgAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpdLatestMsgAction_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpdLatestMsgAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpdLatestMsgAction_UpdMsg:
    case UpdLatestMsgAction_UpdRead:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserType

GPBEnumDescriptor *UserType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "User\000Bot\000";
    static const int32_t values[] = {
        UserType_User,
        UserType_Bot,
    };
    static const char *extraTextFormatInfo = "\002\000\004\000\001\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserType_User:
    case UserType_Bot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BanType

GPBEnumDescriptor *BanType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Permanent\000Temporary\000";
    static const int32_t values[] = {
        BanType_Permanent,
        BanType_Temporary,
    };
    static const char *extraTextFormatInfo = "\002\000\t\000\001\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BanType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BanType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BanType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BanType_Permanent:
    case BanType_Temporary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OnlineType

GPBEnumDescriptor *OnlineType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Offline\000Online\000";
    static const int32_t values[] = {
        OnlineType_Offline,
        OnlineType_Online,
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineType_Offline:
    case OnlineType_Online:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChrmDispatchType

GPBEnumDescriptor *ChrmDispatchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "CreateChatroom\000DestroyChatroom\000";
    static const int32_t values[] = {
        ChrmDispatchType_CreateChatroom,
        ChrmDispatchType_DestroyChatroom,
    };
    static const char *extraTextFormatInfo = "\002\000\016\000\001\017\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChrmDispatchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChrmDispatchType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChrmDispatchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChrmDispatchType_CreateChatroom:
    case ChrmDispatchType_DestroyChatroom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatMembersDispatchType

GPBEnumDescriptor *ChatMembersDispatchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DispatchDefault\000JoinChatroom\000QuitChatroo"
        "m\000";
    static const int32_t values[] = {
        ChatMembersDispatchType_DispatchDefault,
        ChatMembersDispatchType_JoinChatroom,
        ChatMembersDispatchType_QuitChatroom,
    };
    static const char *extraTextFormatInfo = "\003\000\017\000\001\014\000\002\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatMembersDispatchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatMembersDispatchType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatMembersDispatchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatMembersDispatchType_DispatchDefault:
    case ChatMembersDispatchType_JoinChatroom:
    case ChatMembersDispatchType_QuitChatroom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatAttOptType

GPBEnumDescriptor *ChatAttOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ChatAttOptDefault\000ChatAttOptAdd\000ChatAttO"
        "ptDel\000";
    static const int32_t values[] = {
        ChatAttOptType_ChatAttOptDefault,
        ChatAttOptType_ChatAttOptAdd,
        ChatAttOptType_ChatAttOptDel,
    };
    static const char *extraTextFormatInfo = "\003\000\n\207\000\001\n\203\000\002\n\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatAttOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatAttOptType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatAttOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatAttOptType_ChatAttOptDefault:
    case ChatAttOptType_ChatAttOptAdd:
    case ChatAttOptType_ChatAttOptDel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileType

GPBEnumDescriptor *FileType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DefaultFileType\000Image\000Audio\000Video\000File\000L"
        "og\000";
    static const int32_t values[] = {
        FileType_DefaultFileType,
        FileType_Image,
        FileType_Audio,
        FileType_Video,
        FileType_File,
        FileType_Log,
    };
    static const char *extraTextFormatInfo = "\006\000\017\000\001\005\000\002\005\000\003\005\000\004\004\000\005\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileType_DefaultFileType:
    case FileType_Image:
    case FileType_Audio:
    case FileType_Video:
    case FileType_File:
    case FileType_Log:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OssType

GPBEnumDescriptor *OssType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DefaultOss\000QiNiu\000S3\000Minio\000Oss\000";
    static const int32_t values[] = {
        OssType_DefaultOss,
        OssType_QiNiu,
        OssType_S3,
        OssType_Minio,
        OssType_Oss,
    };
    static const char *extraTextFormatInfo = "\004\000\n\000\001\005\000\003\005\000\004\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OssType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OssType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OssType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OssType_DefaultOss:
    case OssType_QiNiu:
    case OssType_S3:
    case OssType_Minio:
    case OssType_Oss:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChrmEventType

GPBEnumDescriptor *ChrmEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Join\000Quit\000Kick\000Fallout\000";
    static const int32_t values[] = {
        ChrmEventType_Join,
        ChrmEventType_Quit,
        ChrmEventType_Kick,
        ChrmEventType_Fallout,
    };
    static const char *extraTextFormatInfo = "\004\000\004\000\001\004\000\002\004\000\003\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChrmEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChrmEventType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChrmEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChrmEventType_Join:
    case ChrmEventType_Quit:
    case ChrmEventType_Kick:
    case ChrmEventType_Fallout:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Nil_Class

@implementation Nil_Class


typedef struct Nil_Class__storage_ {
  uint32_t _has_storage_[1];
} Nil_Class__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Nil_Class)
                                   messageName:@"Nil"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Nil_Class__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RpcMessageWraper

@implementation RpcMessageWraper

@dynamic rpcMsgType;
@dynamic appKey;
@dynamic session;
@dynamic method;
@dynamic targetId;
@dynamic sourceMethod;
@dynamic requesterId;
@dynamic qos;
@dynamic reqIndex;
@dynamic publishType;
@dynamic isFromApi;
@dynamic extParams, extParams_Count;
@dynamic terminalNum;
@dynamic noSendbox;
@dynamic onlySendbox;
@dynamic resultCode;
@dynamic msgSendTime;
@dynamic msgId;
@dynamic msgSeqNo;
@dynamic groupId;
@dynamic targetIdsArray, targetIdsArray_Count;
@dynamic appDataBytes;
@dynamic hasSenderInfo, senderInfo;

typedef struct RpcMessageWraper__storage_ {
  uint32_t _has_storage_[1];
  RpcMsgType rpcMsgType;
  int32_t qos;
  int32_t reqIndex;
  int32_t publishType;
  int32_t terminalNum;
  int32_t resultCode;
  NSString *appKey;
  NSString *session;
  NSString *method;
  NSString *targetId;
  NSString *sourceMethod;
  NSString *requesterId;
  NSMutableDictionary *extParams;
  NSString *msgId;
  NSString *groupId;
  NSMutableArray *targetIdsArray;
  NSData *appDataBytes;
  UserInfo *senderInfo;
  int64_t msgSendTime;
  int64_t msgSeqNo;
} RpcMessageWraper__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rpcMsgType",
        .dataTypeSpecific.enumDescFunc = RpcMsgType_EnumDescriptor,
        .number = RpcMessageWraper_FieldNumber_RpcMsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, rpcMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_AppKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Method,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceMethod",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_SourceMethod,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, sourceMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requesterId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_RequesterId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, requesterId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qos",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Qos,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, qos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reqIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ReqIndex,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, reqIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "publishType",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_PublishType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, publishType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isFromApi",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_IsFromApi,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extParams",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ExtParams,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, extParams),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "terminalNum",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TerminalNum,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, terminalNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noSendbox",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_NoSendbox,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "onlySendbox",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_OnlySendbox,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ResultCode,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, resultCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgSendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgSendTime,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgSendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgId,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgSeqNo,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_GroupId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TargetIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, targetIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appDataBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_AppDataBytes,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, appDataBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "senderInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = RpcMessageWraper_FieldNumber_SenderInfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, senderInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RpcMessageWraper)
                                   messageName:@"RpcMessageWraper"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RpcMessageWraper__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\024\001\n\000\002\006\000\005\010\000\006\014\000\007\013\000\t\010\000\n\013\000\013\t\000\014\t\000\r\013\000\016\t\000\017\013\000\025\n\000"
        "\026\013\000\027\005\000\030\010\000\037\007\000 \000targetIds\0002\014\0003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RpcMessageWraper_RpcMsgType_RawValue(RpcMessageWraper *message) {
  GPBDescriptor *descriptor = [RpcMessageWraper descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RpcMessageWraper_FieldNumber_RpcMsgType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRpcMessageWraper_RpcMsgType_RawValue(RpcMessageWraper *message, int32_t value) {
  GPBDescriptor *descriptor = [RpcMessageWraper descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RpcMessageWraper_FieldNumber_RpcMsgType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UpMsg

@implementation UpMsg

@dynamic msgType;
@dynamic msgContent;
@dynamic flags;
@dynamic clientUid;
@dynamic hasPushData, pushData;
@dynamic hasMentionInfo, mentionInfo;
@dynamic hasReferMsg, referMsg;
@dynamic toUserIdsArray, toUserIdsArray_Count;
@dynamic hasMergedMsgs, mergedMsgs;

typedef struct UpMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t flags;
  NSString *msgType;
  NSData *msgContent;
  NSString *clientUid;
  PushData *pushData;
  MentionInfo *mentionInfo;
  DownMsg *referMsg;
  NSMutableArray *toUserIdsArray;
  MergedMsgs *mergedMsgs;
} UpMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_MsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_MsgContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpMsg__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_Flags,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpMsg__storage_, flags),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientUid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_ClientUid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpMsg__storage_, clientUid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.clazz = GPBObjCClass(PushData),
        .number = UpMsg_FieldNumber_PushData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpMsg__storage_, pushData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionInfo),
        .number = UpMsg_FieldNumber_MentionInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpMsg__storage_, mentionInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "referMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = UpMsg_FieldNumber_ReferMsg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpMsg__storage_, referMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_ToUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpMsg__storage_, toUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = UpMsg_FieldNumber_MergedMsgs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpMsg__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UpMsg)
                                   messageName:@"UpMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\010\001\007\000\002\n\000\004\t\000\005\010\000\006\013\000\007\010\000\010\000toUserIds\000\t\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MergedMsgs

@implementation MergedMsgs

@dynamic channelType;
@dynamic userId;
@dynamic targetId;
@dynamic msgsArray, msgsArray_Count;

typedef struct MergedMsgs__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *userId;
  NSString *targetId;
  NSMutableArray *msgsArray;
} MergedMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MergedMsgs_FieldNumber_ChannelType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergedMsgs_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergedMsgs_FieldNumber_TargetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = MergedMsgs_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MergedMsgs)
                                   messageName:@"MergedMsgs"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MergedMsgs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\013\000\002\006\000\003\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MergedMsgs_ChannelType_RawValue(MergedMsgs *message) {
  GPBDescriptor *descriptor = [MergedMsgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MergedMsgs_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMergedMsgs_ChannelType_RawValue(MergedMsgs *message, int32_t value) {
  GPBDescriptor *descriptor = [MergedMsgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MergedMsgs_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MentionInfo

@implementation MentionInfo

@dynamic mentionType;
@dynamic targetUsersArray, targetUsersArray_Count;

typedef struct MentionInfo__storage_ {
  uint32_t _has_storage_[1];
  MentionType mentionType;
  NSMutableArray *targetUsersArray;
} MentionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mentionType",
        .dataTypeSpecific.enumDescFunc = MentionType_EnumDescriptor,
        .number = MentionInfo_FieldNumber_MentionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MentionInfo__storage_, mentionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetUsersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = MentionInfo_FieldNumber_TargetUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MentionInfo__storage_, targetUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MentionInfo)
                                   messageName:@"MentionInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MentionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\000targetUsers\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MentionInfo_MentionType_RawValue(MentionInfo *message) {
  GPBDescriptor *descriptor = [MentionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionInfo_FieldNumber_MentionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMentionInfo_MentionType_RawValue(MentionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [MentionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionInfo_FieldNumber_MentionType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PushData

@implementation PushData

@dynamic title;
@dynamic pushId;
@dynamic pushText;
@dynamic pushExtraData;

typedef struct PushData__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *pushId;
  NSString *pushText;
  NSString *pushExtraData;
} PushData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushData__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushId",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushData__storage_, pushId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushText",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushData__storage_, pushText),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushExtraData",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushExtraData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PushData__storage_, pushExtraData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PushData)
                                   messageName:@"PushData"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\002\006\000\003\010\000\004\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownMsg

@implementation DownMsg

@dynamic targetId;
@dynamic channelType;
@dynamic msgType;
@dynamic senderId;
@dynamic msgId;
@dynamic msgSeqNo;
@dynamic msgContent;
@dynamic msgTime;
@dynamic flags;
@dynamic isSend;
@dynamic platform;
@dynamic clientUid;
@dynamic hasPushData, pushData;
@dynamic hasMentionInfo, mentionInfo;
@dynamic isRead;
@dynamic hasReferMsg, referMsg;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;
@dynamic hasMergedMsgs, mergedMsgs;
@dynamic undisturbType;
@dynamic memberCount;
@dynamic readCount;
@dynamic unreadIndex;

typedef struct DownMsg__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t flags;
  int32_t undisturbType;
  int32_t memberCount;
  int32_t readCount;
  NSString *targetId;
  NSString *msgType;
  NSString *senderId;
  NSString *msgId;
  NSData *msgContent;
  NSString *platform;
  NSString *clientUid;
  PushData *pushData;
  MentionInfo *mentionInfo;
  DownMsg *referMsg;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  MergedMsgs *mergedMsgs;
  int64_t msgSeqNo;
  int64_t msgTime;
  int64_t unreadIndex;
} DownMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownMsg__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = DownMsg_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownMsg__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_SenderId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownMsg__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgSeqNo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_Flags,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DownMsg__storage_, flags),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isSend",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_IsSend,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_Platform,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DownMsg__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientUid",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_ClientUid,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DownMsg__storage_, clientUid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.clazz = GPBObjCClass(PushData),
        .number = DownMsg_FieldNumber_PushData,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DownMsg__storage_, pushData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionInfo),
        .number = DownMsg_FieldNumber_MentionInfo,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DownMsg__storage_, mentionInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isRead",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_IsRead,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "referMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = DownMsg_FieldNumber_ReferMsg,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DownMsg__storage_, referMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = DownMsg_FieldNumber_TargetUserInfo,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(DownMsg__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = DownMsg_FieldNumber_GroupInfo,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(DownMsg__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = DownMsg_FieldNumber_MergedMsgs,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(DownMsg__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_UndisturbType,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(DownMsg__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MemberCount,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(DownMsg__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_ReadCount,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(DownMsg__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_UnreadIndex,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(DownMsg__storage_, unreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DownMsg)
                                   messageName:@"DownMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\025\001\010\000\002\013\000\003\007\000\004\010\000\005\005\000\006\010\000\007\n\000\010\007\000\n\006\000\014\t\000\r\010\000\016\013\000\017\006\000"
        "\020\010\000\021\016\000\022\t\000\023\n\000\024\r\000\025\013\000\026\t\000\027\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DownMsg_ChannelType_RawValue(DownMsg *message) {
  GPBDescriptor *descriptor = [DownMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownMsg_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDownMsg_ChannelType_RawValue(DownMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [DownMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownMsg_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Notify

@implementation Notify

@dynamic type;
@dynamic syncTime;
@dynamic chatroomId;

typedef struct Notify__storage_ {
  uint32_t _has_storage_[1];
  NotifyType type;
  NSString *chatroomId;
  int64_t syncTime;
} Notify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = NotifyType_EnumDescriptor,
        .number = Notify_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Notify__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Notify_FieldNumber_SyncTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Notify__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = Notify_FieldNumber_ChatroomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Notify__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Notify)
                                   messageName:@"Notify"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Notify__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\002\010\000\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Notify_Type_RawValue(Notify *message) {
  GPBDescriptor *descriptor = [Notify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notify_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetNotify_Type_RawValue(Notify *message, int32_t value) {
  GPBDescriptor *descriptor = [Notify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notify_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SyncMsgReq

@implementation SyncMsgReq

@dynamic syncTime;
@dynamic containsSendBox;
@dynamic sendBoxSyncTime;

typedef struct SyncMsgReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t syncTime;
  int64_t sendBoxSyncTime;
} SyncMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_SyncTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "containsSendBox",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_ContainsSendBox,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendBoxSyncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_SendBoxSyncTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, sendBoxSyncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncMsgReq)
                                   messageName:@"SyncMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\017\000\003\017\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownMsgSet

@implementation DownMsgSet

@dynamic msgsArray, msgsArray_Count;
@dynamic syncTime;
@dynamic isFinished;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;

typedef struct DownMsgSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  int64_t syncTime;
} DownMsgSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = DownMsgSet_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsgSet_FieldNumber_SyncTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsgSet_FieldNumber_IsFinished,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = DownMsgSet_FieldNumber_TargetUserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = DownMsgSet_FieldNumber_GroupInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DownMsgSet)
                                   messageName:@"DownMsgSet"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownMsgSet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\002\010\000\003\n\000\004\016\000\005\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KvItem

@implementation KvItem

@dynamic key;
@dynamic value;
@dynamic updTime;

typedef struct KvItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
  int64_t updTime;
} KvItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = KvItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KvItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = KvItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KvItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updTime",
        .dataTypeSpecific.clazz = Nil,
        .number = KvItem_FieldNumber_UpdTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KvItem__storage_, updTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(KvItem)
                                   messageName:@"KvItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KvItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddGrpAssistantReq

@implementation AddGrpAssistantReq

@dynamic assistantId;
@dynamic targetsArray, targetsArray_Count;

typedef struct AddGrpAssistantReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *assistantId;
  NSMutableArray *targetsArray;
} AddGrpAssistantReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assistantId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddGrpAssistantReq_FieldNumber_AssistantId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddGrpAssistantReq__storage_, assistantId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = AddGrpAssistantReq_FieldNumber_TargetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddGrpAssistantReq__storage_, targetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AddGrpAssistantReq)
                                   messageName:@"AddGrpAssistantReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddGrpAssistantReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleConversation

@implementation SimpleConversation

@dynamic targetId;
@dynamic channelType;
@dynamic msgTime;
@dynamic msgSeq;

typedef struct SimpleConversation__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  int64_t msgTime;
  int64_t msgSeq;
} SimpleConversation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = SimpleConversation_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_MsgTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_MsgSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimpleConversation)
                                   messageName:@"SimpleConversation"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleConversation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\007\000\004\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimpleConversation_ChannelType_RawValue(SimpleConversation *message) {
  GPBDescriptor *descriptor = [SimpleConversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleConversation_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleConversation_ChannelType_RawValue(SimpleConversation *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleConversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleConversation_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AssistantMsgResp

@implementation AssistantMsgResp

@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeq;
@dynamic conversArray, conversArray_Count;

typedef struct AssistantMsgResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  NSMutableArray *conversArray;
  int64_t msgTime;
  int64_t msgSeq;
} AssistantMsgResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgSeq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "conversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = AssistantMsgResp_FieldNumber_ConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, conversArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AssistantMsgResp)
                                   messageName:@"AssistantMsgResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssistantMsgResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\007\000\003\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddHisMsgReq

@implementation AddHisMsgReq

@dynamic senderId;
@dynamic targetId;
@dynamic channelType;
@dynamic sendTime;
@dynamic hasMsg, msg;
@dynamic groupMemberCount;

typedef struct AddHisMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t groupMemberCount;
  NSString *senderId;
  NSString *targetId;
  DownMsg *msg;
  int64_t sendTime;
} AddHisMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_SenderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = AddHisMsgReq_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_SendTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = AddHisMsgReq_FieldNumber_Msg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupMemberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_GroupMemberCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, groupMemberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AddHisMsgReq)
                                   messageName:@"AddHisMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddHisMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\010\000\002\010\000\003\013\000\004\010\000\006P\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AddHisMsgReq_ChannelType_RawValue(AddHisMsgReq *message) {
  GPBDescriptor *descriptor = [AddHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddHisMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAddHisMsgReq_ChannelType_RawValue(AddHisMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [AddHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddHisMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - DelHisMsgsReq

@implementation DelHisMsgsReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgsArray, msgsArray_Count;
@dynamic delScope;

typedef struct DelHisMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t delScope;
  NSString *targetId;
  NSMutableArray *msgsArray;
} DelHisMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DelHisMsgsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = DelHisMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = DelHisMsgsReq_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "delScope",
        .dataTypeSpecific.clazz = Nil,
        .number = DelHisMsgsReq_FieldNumber_DelScope,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, delScope),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelHisMsgsReq)
                                   messageName:@"DelHisMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelHisMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\002\010\000\003\013\000\005\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DelHisMsgsReq_ChannelType_RawValue(DelHisMsgsReq *message) {
  GPBDescriptor *descriptor = [DelHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DelHisMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDelHisMsgsReq_ChannelType_RawValue(DelHisMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [DelHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DelHisMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryLatestMsgReq

@implementation QryLatestMsgReq

@dynamic converId;
@dynamic channelType;

typedef struct QryLatestMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *converId;
} QryLatestMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryLatestMsgReq_FieldNumber_ConverId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryLatestMsgReq__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryLatestMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryLatestMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryLatestMsgReq)
                                   messageName:@"QryLatestMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryLatestMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryLatestMsgReq_ChannelType_RawValue(QryLatestMsgReq *message) {
  GPBDescriptor *descriptor = [QryLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryLatestMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryLatestMsgReq_ChannelType_RawValue(QryLatestMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryLatestMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryLatestMsgResp

@implementation QryLatestMsgResp

@dynamic converId;
@dynamic channelType;
@dynamic msgSeqNo;
@dynamic msgTime;
@dynamic msgId;

typedef struct QryLatestMsgResp__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *converId;
  NSString *msgId;
  int64_t msgSeqNo;
  int64_t msgTime;
} QryLatestMsgResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryLatestMsgResp_FieldNumber_ConverId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryLatestMsgResp__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryLatestMsgResp_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryLatestMsgResp__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = QryLatestMsgResp_FieldNumber_MsgSeqNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryLatestMsgResp__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryLatestMsgResp_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryLatestMsgResp__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryLatestMsgResp_FieldNumber_MsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryLatestMsgResp__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryLatestMsgResp)
                                   messageName:@"QryLatestMsgResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryLatestMsgResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\010\000\002K\000\003\010\000\004\007\000\005\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryLatestMsgResp_ChannelType_RawValue(QryLatestMsgResp *message) {
  GPBDescriptor *descriptor = [QryLatestMsgResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryLatestMsgResp_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryLatestMsgResp_ChannelType_RawValue(QryLatestMsgResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryLatestMsgResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryLatestMsgResp_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryHisMsgsReq

@implementation QryHisMsgsReq

@dynamic targetId;
@dynamic channelType;
@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic msgTypesArray, msgTypesArray_Count;

typedef struct QryHisMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t count;
  int32_t order;
  NSString *targetId;
  NSMutableArray *msgTypesArray;
  int64_t startTime;
} QryHisMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryHisMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_StartTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_Order,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_MsgTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, msgTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryHisMsgsReq)
                                   messageName:@"QryHisMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryHisMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\t\000\006\000msgTypes\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryHisMsgsReq_ChannelType_RawValue(QryHisMsgsReq *message) {
  GPBDescriptor *descriptor = [QryHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryHisMsgsReq_ChannelType_RawValue(QryHisMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryHisMsgByIdsReq

@implementation QryHisMsgByIdsReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct QryHisMsgByIdsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgIdsArray;
} QryHisMsgByIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgByIdsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryHisMsgByIdsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgByIdsReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryHisMsgByIdsReq)
                                   messageName:@"QryHisMsgByIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryHisMsgByIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryHisMsgByIdsReq_ChannelType_RawValue(QryHisMsgByIdsReq *message) {
  GPBDescriptor *descriptor = [QryHisMsgByIdsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgByIdsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryHisMsgByIdsReq_ChannelType_RawValue(QryHisMsgByIdsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryHisMsgByIdsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgByIdsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RecallMsgReq

@implementation RecallMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;
@dynamic msgTime;
@dynamic extsArray, extsArray_Count;

typedef struct RecallMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
  NSMutableArray *extsArray;
  int64_t msgTime;
} RecallMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = RecallMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "extsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = RecallMsgReq_FieldNumber_ExtsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, extsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RecallMsgReq)
                                   messageName:@"RecallMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecallMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\005\000\004\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RecallMsgReq_ChannelType_RawValue(RecallMsgReq *message) {
  GPBDescriptor *descriptor = [RecallMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecallMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRecallMsgReq_ChannelType_RawValue(RecallMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [RecallMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecallMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarkReadReq

@implementation MarkReadReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgsArray, msgsArray_Count;
@dynamic indexScopesArray, indexScopesArray_Count;

typedef struct MarkReadReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgsArray;
  NSMutableArray *indexScopesArray;
} MarkReadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkReadReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MarkReadReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = MarkReadReq_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "indexScopesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(IndexScope),
        .number = MarkReadReq_FieldNumber_IndexScopesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, indexScopesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarkReadReq)
                                   messageName:@"MarkReadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkReadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\004\000indexScopes\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MarkReadReq_ChannelType_RawValue(MarkReadReq *message) {
  GPBDescriptor *descriptor = [MarkReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkReadReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMarkReadReq_ChannelType_RawValue(MarkReadReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MarkReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkReadReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarkGrpMsgReadReq

@implementation MarkGrpMsgReadReq

@dynamic groupId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct MarkGrpMsgReadReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *groupId;
  NSMutableArray *msgIdsArray;
} MarkGrpMsgReadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkGrpMsgReadReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MarkGrpMsgReadReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkGrpMsgReadReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarkGrpMsgReadReq)
                                   messageName:@"MarkGrpMsgReadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkGrpMsgReadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MarkGrpMsgReadReq_ChannelType_RawValue(MarkGrpMsgReadReq *message) {
  GPBDescriptor *descriptor = [MarkGrpMsgReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkGrpMsgReadReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMarkGrpMsgReadReq_ChannelType_RawValue(MarkGrpMsgReadReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MarkGrpMsgReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkGrpMsgReadReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CleanHisMsgReq

@implementation CleanHisMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic cleanMsgTime;
@dynamic cleanScope;
@dynamic senderId;
@dynamic cleanTimeOffset;

typedef struct CleanHisMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t cleanScope;
  NSString *targetId;
  NSString *senderId;
  int64_t cleanMsgTime;
  int64_t cleanTimeOffset;
} CleanHisMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = CleanHisMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cleanMsgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_CleanMsgTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, cleanMsgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cleanScope",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_CleanScope,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, cleanScope),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_SenderId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cleanTimeOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_CleanTimeOffset,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, cleanTimeOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CleanHisMsgReq)
                                   messageName:@"CleanHisMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CleanHisMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\010\000\002\013\000\003\014\000\004\n\000\005\010\000\006\017\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CleanHisMsgReq_ChannelType_RawValue(CleanHisMsgReq *message) {
  GPBDescriptor *descriptor = [CleanHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CleanHisMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCleanHisMsgReq_ChannelType_RawValue(CleanHisMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [CleanHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CleanHisMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimpleMsg

@implementation SimpleMsg

@dynamic msgId;
@dynamic msgTime;
@dynamic msgReadIndex;

typedef struct SimpleMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  int64_t msgTime;
  int64_t msgReadIndex;
} SimpleMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgReadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgReadIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgReadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimpleMsg)
                                   messageName:@"SimpleMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\007\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IndexScope

@implementation IndexScope

@dynamic startIndex;
@dynamic endIndex;

typedef struct IndexScope__storage_ {
  uint32_t _has_storage_[1];
  int64_t startIndex;
  int64_t endIndex;
} IndexScope__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IndexScope_FieldNumber_StartIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IndexScope__storage_, startIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IndexScope_FieldNumber_EndIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IndexScope__storage_, endIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IndexScope)
                                   messageName:@"IndexScope"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IndexScope__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\n\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModifyMsgReq

@implementation ModifyMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeqNo;
@dynamic msgContent;
@dynamic msgType;

typedef struct ModifyMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
  NSData *msgContent;
  NSString *msgType;
  int64_t msgTime;
  int64_t msgSeqNo;
} ModifyMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = ModifyMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgSeqNo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgContent,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ModifyMsgReq)
                                   messageName:@"ModifyMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModifyMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\007\001\010\000\002\013\000\003\005\000\004\007\000\005\010\000\006\n\000\007\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ModifyMsgReq_ChannelType_RawValue(ModifyMsgReq *message) {
  GPBDescriptor *descriptor = [ModifyMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModifyMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetModifyMsgReq_ChannelType_RawValue(ModifyMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ModifyMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModifyMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MergeMsgReq

@implementation MergeMsgReq

@dynamic parentMsgId;
@dynamic hasMergedMsgs, mergedMsgs;

typedef struct MergeMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *parentMsgId;
  MergedMsgs *mergedMsgs;
} MergeMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parentMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergeMsgReq_FieldNumber_ParentMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MergeMsgReq__storage_, parentMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = MergeMsgReq_FieldNumber_MergedMsgs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MergeMsgReq__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MergeMsgReq)
                                   messageName:@"MergeMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MergeMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryMergedMsgsReq

@implementation QryMergedMsgsReq

@dynamic startTime;
@dynamic count;
@dynamic order;

typedef struct QryMergedMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  int64_t startTime;
} QryMergedMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMergedMsgsReq)
                                   messageName:@"QryMergedMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMergedMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgExtItem

@implementation MsgExtItem

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;
@dynamic key;
@dynamic value;

typedef struct MsgExtItem__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
  NSString *key;
  NSString *value;
} MsgExtItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MsgExtItem_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_Key,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MsgExtItem)
                                   messageName:@"MsgExtItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgExtItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MsgExtItem_ChannelType_RawValue(MsgExtItem *message) {
  GPBDescriptor *descriptor = [MsgExtItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgExtItem_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMsgExtItem_ChannelType_RawValue(MsgExtItem *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgExtItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgExtItem_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryGlobalConversReq

@implementation QryGlobalConversReq

@dynamic start;
@dynamic count;
@dynamic order;
@dynamic targetId;
@dynamic channelType;
@dynamic excludeUserIdsArray, excludeUserIdsArray_Count;

typedef struct QryGlobalConversReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *excludeUserIdsArray;
  int64_t start;
} QryGlobalConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, start),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_TargetId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryGlobalConversReq_FieldNumber_ChannelType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "excludeUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_ExcludeUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, excludeUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGlobalConversReq)
                                   messageName:@"QryGlobalConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGlobalConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\004\010\000\005\013\000\006\000excludeUserIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryGlobalConversReq_ChannelType_RawValue(QryGlobalConversReq *message) {
  GPBDescriptor *descriptor = [QryGlobalConversReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryGlobalConversReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryGlobalConversReq_ChannelType_RawValue(QryGlobalConversReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryGlobalConversReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryGlobalConversReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryGlobalConversResp

@implementation QryGlobalConversResp

@dynamic conversArray, conversArray_Count;
@dynamic isFinished;

typedef struct QryGlobalConversResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversArray;
} QryGlobalConversResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GlobalConver),
        .number = QryGlobalConversResp_FieldNumber_ConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryGlobalConversResp__storage_, conversArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGlobalConversResp)
                                   messageName:@"QryGlobalConversResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGlobalConversResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GlobalConver

@implementation GlobalConver

@dynamic id_p;
@dynamic converId;
@dynamic senderId;
@dynamic targetId;
@dynamic channelType;
@dynamic updatedTime;

typedef struct GlobalConver__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *id_p;
  NSString *converId;
  NSString *senderId;
  NSString *targetId;
  int64_t updatedTime;
} GlobalConver__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_ConverId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_SenderId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_TargetId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = GlobalConver_FieldNumber_ChannelType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_UpdatedTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GlobalConver)
                                   messageName:@"GlobalConver"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GlobalConver__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\000Id\000\002\010\000\003\010\000\004\010\000\005\013\000\006\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GlobalConver_ChannelType_RawValue(GlobalConver *message) {
  GPBDescriptor *descriptor = [GlobalConver descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GlobalConver_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGlobalConver_ChannelType_RawValue(GlobalConver *message, int32_t value) {
  GPBDescriptor *descriptor = [GlobalConver descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GlobalConver_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConversationsReq

@implementation QryConversationsReq

@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic targetId;
@dynamic channelType;

typedef struct QryConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  ChannelType channelType;
  NSString *targetId;
  int64_t startTime;
} QryConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_TargetId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConversationsReq_FieldNumber_ChannelType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConversationsReq)
                                   messageName:@"QryConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\t\000\005\010\000\006\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConversationsReq_ChannelType_RawValue(QryConversationsReq *message) {
  GPBDescriptor *descriptor = [QryConversationsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConversationsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConversationsReq_ChannelType_RawValue(QryConversationsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConversationsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConversationsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConversationsResp

@implementation QryConversationsResp

@dynamic conversationsArray, conversationsArray_Count;
@dynamic isFinished;

typedef struct QryConversationsResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} QryConversationsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = QryConversationsResp_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryConversationsResp__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConversationsResp)
                                   messageName:@"QryConversationsResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConversationsResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Conversation

@implementation Conversation

@dynamic userId;
@dynamic targetId;
@dynamic channelType;
@dynamic sortTime;
@dynamic unreadCount;
@dynamic hasMsg, msg;
@dynamic latestReadIndex;
@dynamic hasMentions, mentions;
@dynamic isTop;
@dynamic topUpdatedTime;
@dynamic undisturbType;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;
@dynamic syncTime;
@dynamic isDelete;
@dynamic latestUnreadIndex;
@dynamic unreadTag;
@dynamic latestReadMsgId;
@dynamic latestReadMsgTime;

typedef struct Conversation__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t isTop;
  int32_t undisturbType;
  int32_t isDelete;
  int32_t unreadTag;
  NSString *userId;
  NSString *targetId;
  DownMsg *msg;
  Mentions *mentions;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  NSString *latestReadMsgId;
  int64_t sortTime;
  int64_t unreadCount;
  int64_t latestReadIndex;
  int64_t topUpdatedTime;
  int64_t syncTime;
  int64_t latestUnreadIndex;
  int64_t latestReadMsgTime;
} Conversation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Conversation__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Conversation__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = Conversation_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Conversation__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sortTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_SortTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Conversation__storage_, sortTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UnreadCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Conversation__storage_, unreadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = Conversation_FieldNumber_Msg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Conversation__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latestReadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestReadIndex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestReadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mentions",
        .dataTypeSpecific.clazz = GPBObjCClass(Mentions),
        .number = Conversation_FieldNumber_Mentions,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Conversation__storage_, mentions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isTop",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_IsTop,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Conversation__storage_, isTop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "topUpdatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_TopUpdatedTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Conversation__storage_, topUpdatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UndisturbType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Conversation__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = Conversation_FieldNumber_TargetUserInfo,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Conversation__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = Conversation_FieldNumber_GroupInfo,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Conversation__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_SyncTime,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Conversation__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isDelete",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_IsDelete,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Conversation__storage_, isDelete),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latestUnreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestUnreadIndex,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestUnreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadTag",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UnreadTag,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Conversation__storage_, unreadTag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latestReadMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestReadMsgId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestReadMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latestReadMsgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestReadMsgTime,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestReadMsgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Conversation)
                                   messageName:@"Conversation"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Conversation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\021\001\006\000\002\010\000\003\013\000\004\010\000\005\013\000\007\017\000\t\005\000\n\016\000\013\r\000\014\016\000\r\t\000\016\010\000\017\010\000"
        "\020\021\000\021\t\000\022\017\000\023\021\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Conversation_ChannelType_RawValue(Conversation *message) {
  GPBDescriptor *descriptor = [Conversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Conversation_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetConversation_ChannelType_RawValue(Conversation *message, int32_t value) {
  GPBDescriptor *descriptor = [Conversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Conversation_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UpdLatestMsgReq

@implementation UpdLatestMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic latestMsgId;
@dynamic action;
@dynamic hasMsg, msg;
@dynamic isRead;

typedef struct UpdLatestMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  UpdLatestMsgAction action;
  NSString *targetId;
  NSString *latestMsgId;
  DownMsg *msg;
} UpdLatestMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdLatestMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdLatestMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = UpdLatestMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdLatestMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latestMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdLatestMsgReq_FieldNumber_LatestMsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdLatestMsgReq__storage_, latestMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = UpdLatestMsgAction_EnumDescriptor,
        .number = UpdLatestMsgReq_FieldNumber_Action,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdLatestMsgReq__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = UpdLatestMsgReq_FieldNumber_Msg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdLatestMsgReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isRead",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdLatestMsgReq_FieldNumber_IsRead,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UpdLatestMsgReq)
                                   messageName:@"UpdLatestMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdLatestMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\013\000\006\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UpdLatestMsgReq_ChannelType_RawValue(UpdLatestMsgReq *message) {
  GPBDescriptor *descriptor = [UpdLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdLatestMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUpdLatestMsgReq_ChannelType_RawValue(UpdLatestMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdLatestMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t UpdLatestMsgReq_Action_RawValue(UpdLatestMsgReq *message) {
  GPBDescriptor *descriptor = [UpdLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdLatestMsgReq_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUpdLatestMsgReq_Action_RawValue(UpdLatestMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [UpdLatestMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UpdLatestMsgReq_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Mentions

@implementation Mentions

@dynamic isMentioned;
@dynamic mentionMsgCount;
@dynamic sendersArray, sendersArray_Count;
@dynamic mentionMsgsArray, mentionMsgsArray_Count;

typedef struct Mentions__storage_ {
  uint32_t _has_storage_[1];
  int32_t mentionMsgCount;
  NSMutableArray *sendersArray;
  NSMutableArray *mentionMsgsArray;
} Mentions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMentioned",
        .dataTypeSpecific.clazz = Nil,
        .number = Mentions_FieldNumber_IsMentioned,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mentionMsgCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Mentions_FieldNumber_MentionMsgCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Mentions__storage_, mentionMsgCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = Mentions_FieldNumber_SendersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Mentions__storage_, sendersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionMsgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionMsg),
        .number = Mentions_FieldNumber_MentionMsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Mentions__storage_, mentionMsgsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Mentions)
                                   messageName:@"Mentions"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Mentions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\013\000\002\017\000\004\000mentionMsgs\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MentionMsg

@implementation MentionMsg

@dynamic senderId;
@dynamic msgId;
@dynamic msgTime;

typedef struct MentionMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *senderId;
  NSString *msgId;
  int64_t msgTime;
} MentionMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = MentionMsg_FieldNumber_SenderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MentionMsg_FieldNumber_MsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MentionMsg_FieldNumber_MsgTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MentionMsg)
                                   messageName:@"MentionMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MentionMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\005\000\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryMentionMsgsReq

@implementation QryMentionMsgsReq

@dynamic targetId;
@dynamic channelType;
@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic latestReadIndex;

typedef struct QryMentionMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t count;
  int32_t order;
  NSString *targetId;
  int64_t startTime;
  int64_t latestReadIndex;
} QryMentionMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryMentionMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_StartTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_Order,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latestReadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_LatestReadIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, latestReadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMentionMsgsReq)
                                   messageName:@"QryMentionMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMentionMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\t\000\006\017\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryMentionMsgsReq_ChannelType_RawValue(QryMentionMsgsReq *message) {
  GPBDescriptor *descriptor = [QryMentionMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMentionMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryMentionMsgsReq_ChannelType_RawValue(QryMentionMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryMentionMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMentionMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryMentionMsgsResp

@implementation QryMentionMsgsResp

@dynamic mentionMsgsArray, mentionMsgsArray_Count;
@dynamic isFinished;

typedef struct QryMentionMsgsResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mentionMsgsArray;
} QryMentionMsgsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mentionMsgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = QryMentionMsgsResp_FieldNumber_MentionMsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryMentionMsgsResp__storage_, mentionMsgsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMentionMsgsResp)
                                   messageName:@"QryMentionMsgsResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMentionMsgsResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000mentionMsgs\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncConversationsReq

@implementation SyncConversationsReq

@dynamic startTime;
@dynamic count;

typedef struct SyncConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int64_t startTime;
} SyncConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncConversationsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncConversationsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncConversationsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncConversationsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncConversationsReq)
                                   messageName:@"SyncConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryTotalUnreadCountReq

@implementation QryTotalUnreadCountReq

@dynamic time;
@dynamic hasFilter, filter;

typedef struct QryTotalUnreadCountReq__storage_ {
  uint32_t _has_storage_[1];
  ConverFilter *filter;
  int64_t time;
} QryTotalUnreadCountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTotalUnreadCountReq_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTotalUnreadCountReq__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "filter",
        .dataTypeSpecific.clazz = GPBObjCClass(ConverFilter),
        .number = QryTotalUnreadCountReq_FieldNumber_Filter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryTotalUnreadCountReq__storage_, filter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTotalUnreadCountReq)
                                   messageName:@"QryTotalUnreadCountReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTotalUnreadCountReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConverFilter

@implementation ConverFilter

@dynamic channelTypesArray, channelTypesArray_Count;
@dynamic excludeConversArray, excludeConversArray_Count;
@dynamic includeConversArray, includeConversArray_Count;

typedef struct ConverFilter__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *channelTypesArray;
  NSMutableArray *excludeConversArray;
  NSMutableArray *includeConversArray;
} ConverFilter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelTypesArray",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = ConverFilter_FieldNumber_ChannelTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConverFilter__storage_, channelTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "excludeConversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = ConverFilter_FieldNumber_ExcludeConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConverFilter__storage_, excludeConversArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "includeConversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = ConverFilter_FieldNumber_IncludeConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConverFilter__storage_, includeConversArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ConverFilter)
                                   messageName:@"ConverFilter"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConverFilter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\000channelTypes\000\002\000excludeConvers\000\003\000inclu"
        "deConvers\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryTotalUnreadCountResp

@implementation QryTotalUnreadCountResp

@dynamic totalCount;

typedef struct QryTotalUnreadCountResp__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalCount;
} QryTotalUnreadCountResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTotalUnreadCountResp_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTotalUnreadCountResp__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTotalUnreadCountResp)
                                   messageName:@"QryTotalUnreadCountResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTotalUnreadCountResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConversationsReq

@implementation ConversationsReq

@dynamic conversationsArray, conversationsArray_Count;

typedef struct ConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} ConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = ConversationsReq_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConversationsReq__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ConversationsReq)
                                   messageName:@"ConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClearUnreadReq

@implementation ClearUnreadReq

@dynamic conversationsArray, conversationsArray_Count;
@dynamic noCmdMsg;

typedef struct ClearUnreadReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} ClearUnreadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = ClearUnreadReq_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClearUnreadReq__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "noCmdMsg",
        .dataTypeSpecific.clazz = Nil,
        .number = ClearUnreadReq_FieldNumber_NoCmdMsg,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ClearUnreadReq)
                                   messageName:@"ClearUnreadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClearUnreadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UndisturbConversReq

@implementation UndisturbConversReq

@dynamic itemsArray, itemsArray_Count;

typedef struct UndisturbConversReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} UndisturbConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UndisturbConverItem),
        .number = UndisturbConversReq_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UndisturbConversReq__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UndisturbConversReq)
                                   messageName:@"UndisturbConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UndisturbConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UndisturbConverItem

@implementation UndisturbConverItem

@dynamic targetId;
@dynamic channelType;
@dynamic undisturbType;

typedef struct UndisturbConverItem__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t undisturbType;
  NSString *targetId;
} UndisturbConverItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = UndisturbConverItem_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = UndisturbConverItem_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = UndisturbConverItem_FieldNumber_UndisturbType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UndisturbConverItem)
                                   messageName:@"UndisturbConverItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UndisturbConverItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UndisturbConverItem_ChannelType_RawValue(UndisturbConverItem *message) {
  GPBDescriptor *descriptor = [UndisturbConverItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UndisturbConverItem_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUndisturbConverItem_ChannelType_RawValue(UndisturbConverItem *message, int32_t value) {
  GPBDescriptor *descriptor = [UndisturbConverItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UndisturbConverItem_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryTopConversReq

@implementation QryTopConversReq

@dynamic startTime;

typedef struct QryTopConversReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t startTime;
} QryTopConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTopConversReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTopConversReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTopConversReq)
                                   messageName:@"QryTopConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTopConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TopConversResp

@implementation TopConversResp

@dynamic optTime;

typedef struct TopConversResp__storage_ {
  uint32_t _has_storage_[1];
  int64_t optTime;
} TopConversResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optTime",
        .dataTypeSpecific.clazz = Nil,
        .number = TopConversResp_FieldNumber_OptTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TopConversResp__storage_, optTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TopConversResp)
                                   messageName:@"TopConversResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TopConversResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryReadInfosReq

@implementation QryReadInfosReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct QryReadInfosReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgIdsArray;
} QryReadInfosReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadInfosReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryReadInfosReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadInfosReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadInfosReq)
                                   messageName:@"QryReadInfosReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadInfosReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryReadInfosReq_ChannelType_RawValue(QryReadInfosReq *message) {
  GPBDescriptor *descriptor = [QryReadInfosReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadInfosReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryReadInfosReq_ChannelType_RawValue(QryReadInfosReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryReadInfosReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadInfosReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryReadInfosResp

@implementation QryReadInfosResp

@dynamic itemsArray, itemsArray_Count;

typedef struct QryReadInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} QryReadInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReadInfoItem),
        .number = QryReadInfosResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadInfosResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadInfosResp)
                                   messageName:@"QryReadInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadInfoItem

@implementation ReadInfoItem

@dynamic msgId;
@dynamic readCount;
@dynamic totalCount;

typedef struct ReadInfoItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t readCount;
  int32_t totalCount;
  NSString *msgId;
} ReadInfoItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_ReadCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_TotalCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReadInfoItem)
                                   messageName:@"ReadInfoItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReadInfoItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\t\000\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryReadDetailReq

@implementation QryReadDetailReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;

typedef struct QryReadDetailReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
} QryReadDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryReadDetailReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadDetailReq)
                                   messageName:@"QryReadDetailReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadDetailReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryReadDetailReq_ChannelType_RawValue(QryReadDetailReq *message) {
  GPBDescriptor *descriptor = [QryReadDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadDetailReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryReadDetailReq_ChannelType_RawValue(QryReadDetailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryReadDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadDetailReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryReadDetailResp

@implementation QryReadDetailResp

@dynamic readCount;
@dynamic memberCount;
@dynamic readMembersArray, readMembersArray_Count;
@dynamic unreadMembersArray, unreadMembersArray_Count;

typedef struct QryReadDetailResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t readCount;
  int32_t memberCount;
  NSMutableArray *readMembersArray;
  NSMutableArray *unreadMembersArray;
} QryReadDetailResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailResp_FieldNumber_ReadCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailResp_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "readMembersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MemberReadDetailItem),
        .number = QryReadDetailResp_FieldNumber_ReadMembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, readMembersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadMembersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MemberReadDetailItem),
        .number = QryReadDetailResp_FieldNumber_UnreadMembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, unreadMembersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadDetailResp)
                                   messageName:@"QryReadDetailResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadDetailResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\t\000\002\013\000\003\000readMembers\000\004\000unreadMembers\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberReadDetailItem

@implementation MemberReadDetailItem

@dynamic hasMember, member;
@dynamic time;

typedef struct MemberReadDetailItem__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *member;
  int64_t time;
} MemberReadDetailItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "member",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = MemberReadDetailItem_FieldNumber_Member,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberReadDetailItem__storage_, member),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = MemberReadDetailItem_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberReadDetailItem__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MemberReadDetailItem)
                                   messageName:@"MemberReadDetailItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberReadDetailItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryConverReq

@implementation QryConverReq

@dynamic targetId;
@dynamic channelType;
@dynamic isInner;

typedef struct QryConverReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
} QryConverReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConverReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConverReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConverReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isInner",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverReq_FieldNumber_IsInner,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConverReq)
                                   messageName:@"QryConverReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConverReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConverReq_ChannelType_RawValue(QryConverReq *message) {
  GPBDescriptor *descriptor = [QryConverReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConverReq_ChannelType_RawValue(QryConverReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConverReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConverResp

@implementation QryConverResp

@dynamic targetId;
@dynamic channelType;
@dynamic unreadIndex;
@dynamic undisturbType;

typedef struct QryConverResp__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t undisturbType;
  NSString *targetId;
  int64_t unreadIndex;
} QryConverResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConverResp_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_UnreadIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, unreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_UndisturbType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConverResp)
                                   messageName:@"QryConverResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConverResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\013\000\004\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConverResp_ChannelType_RawValue(QryConverResp *message) {
  GPBDescriptor *descriptor = [QryConverResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverResp_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConverResp_ChannelType_RawValue(QryConverResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConverResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverResp_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UserInfo

@implementation UserInfo

@dynamic userId;
@dynamic nickname;
@dynamic userPortrait;
@dynamic extFieldsArray, extFieldsArray_Count;
@dynamic updatedTime;
@dynamic settingsArray, settingsArray_Count;
@dynamic statusesArray, statusesArray_Count;
@dynamic userType;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  UserType userType;
  NSString *userId;
  NSString *nickname;
  NSString *userPortrait;
  NSMutableArray *extFieldsArray;
  NSMutableArray *settingsArray;
  NSMutableArray *statusesArray;
  int64_t updatedTime;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, nickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = UserInfo_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfo__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UpdatedTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = UserInfo_FieldNumber_SettingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfo__storage_, settingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statusesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = UserInfo_FieldNumber_StatusesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfo__storage_, statusesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userType",
        .dataTypeSpecific.enumDescFunc = UserType_EnumDescriptor,
        .number = UserInfo_FieldNumber_UserType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserInfo)
                                   messageName:@"UserInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\006\000\003\014\000\004\000extFields\000\005\013\000\010\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserInfo_UserType_RawValue(UserInfo *message) {
  GPBDescriptor *descriptor = [UserInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfo_FieldNumber_UserType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUserInfo_UserType_RawValue(UserInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [UserInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfo_FieldNumber_UserType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UserInfos

@implementation UserInfos

@dynamic userInfosArray, userInfosArray_Count;

typedef struct UserInfos__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userInfosArray;
} UserInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = UserInfos_FieldNumber_UserInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfos__storage_, userInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserInfos)
                                   messageName:@"UserInfos"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfos__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000userInfos\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserIdsReq

@implementation UserIdsReq

@dynamic userIdsArray, userIdsArray_Count;
@dynamic attTypesArray, attTypesArray_Count;
@dynamic noDispatch;

typedef struct UserIdsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
  GPBInt32Array *attTypesArray;
} UserIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdsReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserIdsReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdsReq_FieldNumber_AttTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserIdsReq__storage_, attTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noDispatch",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdsReq_FieldNumber_NoDispatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserIdsReq)
                                   messageName:@"UserIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\000userIds\000\002\000attTypes\000\013\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserIdReq

@implementation UserIdReq

@dynamic userId;
@dynamic attTypesArray, attTypesArray_Count;

typedef struct UserIdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  GPBInt32Array *attTypesArray;
} UserIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserIdReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdReq_FieldNumber_AttTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserIdReq__storage_, attTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserIdReq)
                                   messageName:@"UserIdReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserIdReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\000attTypes\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfosResp

@implementation UserInfosResp

@dynamic userInfoMap, userInfoMap_Count;

typedef struct UserInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *userInfoMap;
} UserInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfoMap",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = UserInfosResp_FieldNumber_UserInfoMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfosResp__storage_, userInfoMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserInfosResp)
                                   messageName:@"UserInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserRegResp

@implementation UserRegResp

@dynamic userId;
@dynamic token;

typedef struct UserRegResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *token;
} UserRegResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRegResp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserRegResp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRegResp_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserRegResp__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserRegResp)
                                   messageName:@"UserRegResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserRegResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineStatusReq

@implementation UserOnlineStatusReq

@dynamic userIdsArray, userIdsArray_Count;

typedef struct UserOnlineStatusReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} UserOnlineStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineStatusReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserOnlineStatusReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineStatusReq)
                                   messageName:@"UserOnlineStatusReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineStatusReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000userIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineStatusResp

@implementation UserOnlineStatusResp

@dynamic itemsArray, itemsArray_Count;

typedef struct UserOnlineStatusResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} UserOnlineStatusResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOnlineItem),
        .number = UserOnlineStatusResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserOnlineStatusResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineStatusResp)
                                   messageName:@"UserOnlineStatusResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineStatusResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineItem

@implementation UserOnlineItem

@dynamic userId;
@dynamic isOnline;

typedef struct UserOnlineItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} UserOnlineItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineItem_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserOnlineItem__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isOnline",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineItem_FieldNumber_IsOnline,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineItem)
                                   messageName:@"UserOnlineItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BanUsersReq

@implementation BanUsersReq

@dynamic banUsersArray, banUsersArray_Count;
@dynamic isAdd;

typedef struct BanUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *banUsersArray;
} BanUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "banUsersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BanUser),
        .number = BanUsersReq_FieldNumber_BanUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BanUsersReq__storage_, banUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isAdd",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUsersReq_FieldNumber_IsAdd,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanUsersReq)
                                   messageName:@"BanUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000banUsers\000\002\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BanUser

@implementation BanUser

@dynamic userId;
@dynamic banType;
@dynamic endTime;
@dynamic createdTime;
@dynamic scopeKey;
@dynamic scopeValue;
@dynamic ext;

typedef struct BanUser__storage_ {
  uint32_t _has_storage_[1];
  BanType banType;
  NSString *userId;
  NSString *scopeKey;
  NSString *scopeValue;
  NSString *ext;
  int64_t endTime;
  int64_t createdTime;
} BanUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BanUser__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = BanType_EnumDescriptor,
        .number = BanUser_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BanUser__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BanUser__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_CreatedTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BanUser__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "scopeKey",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_ScopeKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BanUser__storage_, scopeKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scopeValue",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_ScopeValue,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BanUser__storage_, scopeValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_Ext,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BanUser__storage_, ext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanUser)
                                   messageName:@"BanUser"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\006\000\002\007\000\003\007\000\004\013\000\005\010\000\006\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BanUser_BanType_RawValue(BanUser *message) {
  GPBDescriptor *descriptor = [BanUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUser_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBanUser_BanType_RawValue(BanUser *message, int32_t value) {
  GPBDescriptor *descriptor = [BanUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUser_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryBanUsersReq

@implementation QryBanUsersReq

@dynamic limit;
@dynamic offset;

typedef struct QryBanUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *offset;
  int64_t limit;
} QryBanUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersReq_FieldNumber_Limit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBanUsersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersReq_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryBanUsersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBanUsersReq)
                                   messageName:@"QryBanUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBanUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBanUsersResp

@implementation QryBanUsersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct QryBanUsersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} QryBanUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BanUser),
        .number = QryBanUsersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryBanUsersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBanUsersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBanUsersResp)
                                   messageName:@"QryBanUsersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBanUsersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockUsersReq

@implementation BlockUsersReq

@dynamic userIdsArray, userIdsArray_Count;
@dynamic isAdd;

typedef struct BlockUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} BlockUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUsersReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockUsersReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAdd",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUsersReq_FieldNumber_IsAdd,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockUsersReq)
                                   messageName:@"BlockUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000userIds\000\002\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBlockUsersReq

@implementation QryBlockUsersReq

@dynamic userId;
@dynamic limit;
@dynamic offset;

typedef struct QryBlockUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *offset;
  int64_t limit;
} QryBlockUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBlockUsersReq)
                                   messageName:@"QryBlockUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBlockUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockUser

@implementation BlockUser

@dynamic blockUserId;
@dynamic createdTime;

typedef struct BlockUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *blockUserId;
  int64_t createdTime;
} BlockUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUser_FieldNumber_BlockUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockUser__storage_, blockUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUser_FieldNumber_CreatedTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockUser__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockUser)
                                   messageName:@"BlockUser"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBlockUsersResp

@implementation QryBlockUsersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct QryBlockUsersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} QryBlockUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockUser),
        .number = QryBlockUsersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryBlockUsersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBlockUsersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBlockUsersResp)
                                   messageName:@"QryBlockUsersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBlockUsersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineStatus

@implementation OnlineStatus

@dynamic type;
@dynamic extraData;

typedef struct OnlineStatus__storage_ {
  uint32_t _has_storage_[1];
  OnlineType type;
  NSData *extraData;
} OnlineStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = OnlineType_EnumDescriptor,
        .number = OnlineStatus_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineStatus__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extraData",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineStatus_FieldNumber_ExtraData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineStatus__storage_, extraData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnlineStatus)
                                   messageName:@"OnlineStatus"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\013\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OnlineStatus_Type_RawValue(OnlineStatus *message) {
  GPBDescriptor *descriptor = [OnlineStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineStatus_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOnlineStatus_Type_RawValue(OnlineStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [OnlineStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineStatus_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - KickUserReq

@implementation KickUserReq

@dynamic userId;
@dynamic ext;
@dynamic platformsArray, platformsArray_Count;
@dynamic deviceIdsArray, deviceIdsArray_Count;
@dynamic ipsArray, ipsArray_Count;

typedef struct KickUserReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *ext;
  NSMutableArray *platformsArray;
  NSMutableArray *deviceIdsArray;
  NSMutableArray *ipsArray;
} KickUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, ext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_PlatformsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, platformsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_DeviceIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, deviceIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ipsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_IpsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, ipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(KickUserReq)
                                   messageName:@"KickUserReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KickUserReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\004\000deviceIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserUndisturb

@implementation UserUndisturb

@dynamic switch_p;
@dynamic timezone;
@dynamic rulesArray, rulesArray_Count;

typedef struct UserUndisturb__storage_ {
  uint32_t _has_storage_[1];
  NSString *timezone;
  NSMutableArray *rulesArray;
} UserUndisturb__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "switch_p",
        .dataTypeSpecific.clazz = Nil,
        .number = UserUndisturb_FieldNumber_Switch_p,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timezone",
        .dataTypeSpecific.clazz = Nil,
        .number = UserUndisturb_FieldNumber_Timezone,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserUndisturb__storage_, timezone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rulesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserUndisturbItem),
        .number = UserUndisturb_FieldNumber_RulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserUndisturb__storage_, rulesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserUndisturb)
                                   messageName:@"UserUndisturb"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserUndisturb__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserUndisturbItem

@implementation UserUndisturbItem

@dynamic start;
@dynamic end;

typedef struct UserUndisturbItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *start;
  NSString *end;
} UserUndisturbItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = Nil,
        .number = UserUndisturbItem_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserUndisturbItem__storage_, start),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "end",
        .dataTypeSpecific.clazz = Nil,
        .number = UserUndisturbItem_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserUndisturbItem__storage_, end),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserUndisturbItem)
                                   messageName:@"UserUndisturbItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserUndisturbItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic groupId;
@dynamic groupName;
@dynamic groupPortrait;
@dynamic isMute;
@dynamic extFieldsArray, extFieldsArray_Count;
@dynamic updatedTime;
@dynamic settingsArray, settingsArray_Count;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
  NSString *groupName;
  NSString *groupPortrait;
  NSMutableArray *extFieldsArray;
  NSMutableArray *settingsArray;
  int64_t updatedTime;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_IsMute,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = GroupInfo_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_UpdatedTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = GroupInfo_FieldNumber_SettingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, settingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfo)
                                   messageName:@"GroupInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\007\000\002\t\000\003\r\000\004\006\000\005\000extFields\000\006\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMembersReq

@implementation GroupMembersReq

@dynamic groupId;
@dynamic groupName;
@dynamic groupPortrait;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic extFieldsArray, extFieldsArray_Count;

typedef struct GroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *groupName;
  NSString *groupPortrait;
  NSMutableArray *memberIdsArray;
  NSMutableArray *extFieldsArray;
} GroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = GroupMembersReq_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMembersReq)
                                   messageName:@"GroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\007\000\002\t\000\003\r\000\004\000memberIds\000\005\000extFields\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMuteReq

@implementation GroupMuteReq

@dynamic groupId;
@dynamic isMute;

typedef struct GroupMuteReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
} GroupMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMuteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMuteReq_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMuteReq)
                                   messageName:@"GroupMuteReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMuteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoReq

@implementation GroupInfoReq

@dynamic groupId;
@dynamic careFieldsArray, careFieldsArray_Count;

typedef struct GroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *careFieldsArray;
} GroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "careFieldsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfoReq_FieldNumber_CareFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfoReq__storage_, careFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfoReq)
                                   messageName:@"GroupInfoReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000careFields\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupIdsReq

@implementation GroupIdsReq

@dynamic groupIdsArray, groupIdsArray_Count;
@dynamic noDispatch;

typedef struct GroupIdsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupIdsArray;
} GroupIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupIdsReq_FieldNumber_GroupIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupIdsReq__storage_, groupIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noDispatch",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupIdsReq_FieldNumber_NoDispatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupIdsReq)
                                   messageName:@"GroupIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000groupIds\000\013\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfosResp

@implementation GroupInfosResp

@dynamic groupInfoMap, groupInfoMap_Count;

typedef struct GroupInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *groupInfoMap;
} GroupInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupInfoMap",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = GroupInfosResp_FieldNumber_GroupInfoMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfosResp__storage_, groupInfoMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfosResp)
                                   messageName:@"GroupInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMemberMuteReq

@implementation GroupMemberMuteReq

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic isMute;

typedef struct GroupMemberMuteReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} GroupMemberMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMemberMuteReq)
                                   messageName:@"GroupMemberMuteReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMemberMuteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\002\000memberIds\000\003\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMemberAllowReq

@implementation GroupMemberAllowReq

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic isAllow;

typedef struct GroupMemberAllowReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t isAllow;
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} GroupMemberAllowReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberAllowReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMemberAllowReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberAllowReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMemberAllowReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAllow",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberAllowReq_FieldNumber_IsAllow,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMemberAllowReq__storage_, isAllow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMemberAllowReq)
                                   messageName:@"GroupMemberAllowReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMemberAllowReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\002\000memberIds\000\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMembersResp

@implementation GroupMembersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct GroupMembersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} GroupMembersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupMember),
        .number = GroupMembersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMembersResp)
                                   messageName:@"GroupMembersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMember

@implementation GroupMember

@dynamic memberId;
@dynamic isMute;
@dynamic isAllow;

typedef struct GroupMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  int32_t isAllow;
  NSString *memberId;
} GroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMember_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMember__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isAllow",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMember_FieldNumber_IsAllow,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMember__storage_, isAllow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMember)
                                   messageName:@"GroupMember"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\006\000\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGroupMembersReq

@implementation QryGroupMembersReq

@dynamic groupId;
@dynamic limit;
@dynamic offset;

typedef struct QryGroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *offset;
  int64_t limit;
} QryGroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGroupMembersReq)
                                   messageName:@"QryGroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckGroupMembersReq

@implementation CheckGroupMembersReq

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;

typedef struct CheckGroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} CheckGroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckGroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckGroupMembersReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CheckGroupMembersReq)
                                   messageName:@"CheckGroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckGroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000memberIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckGroupMembersResp

@implementation CheckGroupMembersResp

@dynamic memberIdMap, memberIdMap_Count;

typedef struct CheckGroupMembersResp__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt64Dictionary *memberIdMap;
} CheckGroupMembersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberIdMap",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersResp_FieldNumber_MemberIdMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckGroupMembersResp__storage_, memberIdMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CheckGroupMembersResp)
                                   messageName:@"CheckGroupMembersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckGroupMembersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGrpSnapshotReq

@implementation QryGrpSnapshotReq

@dynamic groupId;
@dynamic nearlyTime;

typedef struct QryGrpSnapshotReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  int64_t nearlyTime;
} QryGrpSnapshotReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpSnapshotReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGrpSnapshotReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nearlyTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpSnapshotReq_FieldNumber_NearlyTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGrpSnapshotReq__storage_, nearlyTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGrpSnapshotReq)
                                   messageName:@"QryGrpSnapshotReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGrpSnapshotReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSnapshot

@implementation GroupSnapshot

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;

typedef struct GroupSnapshot__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} GroupSnapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupSnapshot_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSnapshot__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupSnapshot_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupSnapshot__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupSnapshot)
                                   messageName:@"GroupSnapshot"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSnapshot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000memberIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGrpMemberSettingsReq

@implementation QryGrpMemberSettingsReq

@dynamic memberId;

typedef struct QryGrpMemberSettingsReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
} QryGrpMemberSettingsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsReq_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsReq__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGrpMemberSettingsReq)
                                   messageName:@"QryGrpMemberSettingsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGrpMemberSettingsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGrpMemberSettingsResp

@implementation QryGrpMemberSettingsResp

@dynamic groupId;
@dynamic memberId;
@dynamic isMember;
@dynamic joinTime;
@dynamic groupSettings, groupSettings_Count;
@dynamic memberSettings, memberSettings_Count;

typedef struct QryGrpMemberSettingsResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *memberId;
  NSMutableDictionary *groupSettings;
  NSMutableDictionary *memberSettings;
  int64_t joinTime;
} QryGrpMemberSettingsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsResp__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_MemberId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsResp__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMember",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_IsMember,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_JoinTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsResp__storage_, joinTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupSettings",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_GroupSettings,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsResp__storage_, groupSettings),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberSettings",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpMemberSettingsResp_FieldNumber_MemberSettings,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryGrpMemberSettingsResp__storage_, memberSettings),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGrpMemberSettingsResp)
                                   messageName:@"QryGrpMemberSettingsResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGrpMemberSettingsResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\007\000\002\010\000\003\010\000\004\010\000\005\r\000\006\016\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryFirstUnreadMsgReq

@implementation QryFirstUnreadMsgReq

@dynamic targetId;
@dynamic channelType;

typedef struct QryFirstUnreadMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
} QryFirstUnreadMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryFirstUnreadMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryFirstUnreadMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryFirstUnreadMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryFirstUnreadMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryFirstUnreadMsgReq)
                                   messageName:@"QryFirstUnreadMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryFirstUnreadMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryFirstUnreadMsgReq_ChannelType_RawValue(QryFirstUnreadMsgReq *message) {
  GPBDescriptor *descriptor = [QryFirstUnreadMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFirstUnreadMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryFirstUnreadMsgReq_ChannelType_RawValue(QryFirstUnreadMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryFirstUnreadMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFirstUnreadMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SyncChatroomReq

@implementation SyncChatroomReq

@dynamic chatroomId;
@dynamic syncTime;
@dynamic attSyncTime;

typedef struct SyncChatroomReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatroomId;
  int64_t syncTime;
  int64_t attSyncTime;
} SyncChatroomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_ChatroomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_SyncTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attSyncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_AttSyncTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, attSyncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomReq)
                                   messageName:@"SyncChatroomReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\n\000\002\010\000\003\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomMsgResp

@implementation SyncChatroomMsgResp

@dynamic msgsArray, msgsArray_Count;

typedef struct SyncChatroomMsgResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
} SyncChatroomMsgResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = SyncChatroomMsgResp_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncChatroomMsgResp__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomMsgResp)
                                   messageName:@"SyncChatroomMsgResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomMsgResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomResp

@implementation SyncChatroomResp

@dynamic hasMsgs, msgs;
@dynamic hasAtts, atts;
@dynamic isFinished;

typedef struct SyncChatroomResp__storage_ {
  uint32_t _has_storage_[1];
  DownMsgSet *msgs;
  ChatAtts *atts;
} SyncChatroomResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgs",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsgSet),
        .number = SyncChatroomResp_FieldNumber_Msgs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncChatroomResp__storage_, msgs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atts",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAtts),
        .number = SyncChatroomResp_FieldNumber_Atts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncChatroomResp__storage_, atts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomResp_FieldNumber_IsFinished,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomResp)
                                   messageName:@"SyncChatroomResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomInfo

@implementation ChatroomInfo

@dynamic chatId;
@dynamic chatName;
@dynamic membersArray, membersArray_Count;

typedef struct ChatroomInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSString *chatName;
  NSMutableArray *membersArray;
} ChatroomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomInfo_FieldNumber_ChatName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, chatName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatroomMember),
        .number = ChatroomInfo_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatroomInfo__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomInfo)
                                   messageName:@"ChatroomInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMsgNode

@implementation ChatMsgNode

@dynamic nodeName;
@dynamic method;

typedef struct ChatMsgNode__storage_ {
  uint32_t _has_storage_[1];
  NSString *nodeName;
  NSString *method;
} ChatMsgNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMsgNode_FieldNumber_NodeName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMsgNode__storage_, nodeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMsgNode_FieldNumber_Method,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMsgNode__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatMsgNode)
                                   messageName:@"ChatMsgNode"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMsgNode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatroomMember

@implementation ChatroomMember

@dynamic memberId;
@dynamic memberName;
@dynamic addedTime;

typedef struct ChatroomMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
  NSString *memberName;
  int64_t addedTime;
} ChatroomMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_MemberName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatroomMember_FieldNumber_AddedTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatroomMember__storage_, addedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatroomMember)
                                   messageName:@"ChatroomMember"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatroomMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\n\000\003\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChrmDispatchReq

@implementation ChrmDispatchReq

@dynamic chatId;
@dynamic dispatchType;

typedef struct ChrmDispatchReq__storage_ {
  uint32_t _has_storage_[1];
  ChrmDispatchType dispatchType;
  NSString *chatId;
} ChrmDispatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmDispatchReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChrmDispatchReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dispatchType",
        .dataTypeSpecific.enumDescFunc = ChrmDispatchType_EnumDescriptor,
        .number = ChrmDispatchReq_FieldNumber_DispatchType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChrmDispatchReq__storage_, dispatchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChrmDispatchReq)
                                   messageName:@"ChrmDispatchReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChrmDispatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChrmDispatchReq_DispatchType_RawValue(ChrmDispatchReq *message) {
  GPBDescriptor *descriptor = [ChrmDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmDispatchReq_FieldNumber_DispatchType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChrmDispatchReq_DispatchType_RawValue(ChrmDispatchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ChrmDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmDispatchReq_FieldNumber_DispatchType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatMembersDispatchReq

@implementation ChatMembersDispatchReq

@dynamic chatId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic dispatchType;

typedef struct ChatMembersDispatchReq__storage_ {
  uint32_t _has_storage_[1];
  ChatMembersDispatchType dispatchType;
  NSString *chatId;
  NSMutableArray *memberIdsArray;
} ChatMembersDispatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dispatchType",
        .dataTypeSpecific.enumDescFunc = ChatMembersDispatchType_EnumDescriptor,
        .number = ChatMembersDispatchReq_FieldNumber_DispatchType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, dispatchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatMembersDispatchReq)
                                   messageName:@"ChatMembersDispatchReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMembersDispatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\002\000memberIds\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAttBatchReq

@implementation ChatAttBatchReq

@dynamic attsArray, attsArray_Count;

typedef struct ChatAttBatchReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attsArray;
} ChatAttBatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttReq),
        .number = ChatAttBatchReq_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAttBatchReq__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttBatchReq)
                                   messageName:@"ChatAttBatchReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttBatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttReq

@implementation ChatAttReq

@dynamic key;
@dynamic value;
@dynamic isForce;
@dynamic isAutoDel;
@dynamic hasMsg, msg;

typedef struct ChatAttReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
  UpMsg *msg;
} ChatAttReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isForce",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_IsForce,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isAutoDel",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_IsAutoDel,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(UpMsg),
        .number = ChatAttReq_FieldNumber_Msg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttReq)
                                   messageName:@"ChatAttReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\003\007\000\004\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttBatchResp

@implementation ChatAttBatchResp

@dynamic attRespsArray, attRespsArray_Count;

typedef struct ChatAttBatchResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attRespsArray;
} ChatAttBatchResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attRespsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttResp),
        .number = ChatAttBatchResp_FieldNumber_AttRespsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAttBatchResp__storage_, attRespsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttBatchResp)
                                   messageName:@"ChatAttBatchResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttBatchResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000attResps\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttResp

@implementation ChatAttResp

@dynamic key;
@dynamic code;
@dynamic attTime;
@dynamic msgCode;
@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeq;

typedef struct ChatAttResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t msgCode;
  NSString *key;
  NSString *msgId;
  int64_t attTime;
  int64_t msgTime;
  int64_t msgSeq;
} ChatAttResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_AttTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, attTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttResp_FieldNumber_MsgSeq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatAttResp__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttResp)
                                   messageName:@"ChatAttResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\003\007\000\013\007\000\014\005\000\r\007\000\016\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomAttResp

@implementation SyncChatroomAttResp

@dynamic attsArray, attsArray_Count;

typedef struct SyncChatroomAttResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attsArray;
} SyncChatroomAttResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = SyncChatroomAttResp_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncChatroomAttResp__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomAttResp)
                                   messageName:@"SyncChatroomAttResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomAttResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttItem

@implementation ChatAttItem

@dynamic key;
@dynamic value;
@dynamic attTime;
@dynamic userId;
@dynamic optType;

typedef struct ChatAttItem__storage_ {
  uint32_t _has_storage_[1];
  ChatAttOptType optType;
  NSString *key;
  NSString *value;
  NSString *userId;
  int64_t attTime;
} ChatAttItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_AttTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, attTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "optType",
        .dataTypeSpecific.enumDescFunc = ChatAttOptType_EnumDescriptor,
        .number = ChatAttItem_FieldNumber_OptType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, optType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttItem)
                                   messageName:@"ChatAttItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\003\007\000\004\006\000\005\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatAttItem_OptType_RawValue(ChatAttItem *message) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatAttItem_OptType_RawValue(ChatAttItem *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAtts

@implementation ChatAtts

@dynamic chatId;
@dynamic attsArray, attsArray_Count;
@dynamic isComplete;
@dynamic isFinished;

typedef struct ChatAtts__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSMutableArray *attsArray;
} ChatAtts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = ChatAtts_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isComplete",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsComplete,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsFinished,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAtts)
                                   messageName:@"ChatAtts"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAtts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\003\n\000\004\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryChatroomMembersReq

@implementation QryChatroomMembersReq

@dynamic count;
@dynamic order;

typedef struct QryChatroomMembersReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
} QryChatroomMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomMembersReq_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryChatroomMembersReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryChatroomMembersReq_FieldNumber_Order,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryChatroomMembersReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryChatroomMembersReq)
                                   messageName:@"QryChatroomMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryChatroomMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryFileCredReq

@implementation QryFileCredReq

@dynamic fileType;
@dynamic ext;

typedef struct QryFileCredReq__storage_ {
  uint32_t _has_storage_[1];
  FileType fileType;
  NSString *ext;
} QryFileCredReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileType",
        .dataTypeSpecific.enumDescFunc = FileType_EnumDescriptor,
        .number = QryFileCredReq_FieldNumber_FileType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryFileCredReq__storage_, fileType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = Nil,
        .number = QryFileCredReq_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryFileCredReq__storage_, ext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryFileCredReq)
                                   messageName:@"QryFileCredReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryFileCredReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryFileCredReq_FileType_RawValue(QryFileCredReq *message) {
  GPBDescriptor *descriptor = [QryFileCredReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredReq_FieldNumber_FileType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryFileCredReq_FileType_RawValue(QryFileCredReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryFileCredReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredReq_FieldNumber_FileType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryFileCredResp

@implementation QryFileCredResp

@dynamic ossOfOneOfCase;
@dynamic ossType;
@dynamic qiNiuCred;
@dynamic preSignResp;

typedef struct QryFileCredResp__storage_ {
  uint32_t _has_storage_[2];
  OssType ossType;
  QiNiuCredResp *qiNiuCred;
  PreSignResp *preSignResp;
} QryFileCredResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ossType",
        .dataTypeSpecific.enumDescFunc = OssType_EnumDescriptor,
        .number = QryFileCredResp_FieldNumber_OssType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryFileCredResp__storage_, ossType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "qiNiuCred",
        .dataTypeSpecific.clazz = GPBObjCClass(QiNiuCredResp),
        .number = QryFileCredResp_FieldNumber_QiNiuCred,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QryFileCredResp__storage_, qiNiuCred),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preSignResp",
        .dataTypeSpecific.clazz = GPBObjCClass(PreSignResp),
        .number = QryFileCredResp_FieldNumber_PreSignResp,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QryFileCredResp__storage_, preSignResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryFileCredResp)
                                   messageName:@"QryFileCredResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryFileCredResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "ossOf",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\013\t\000\014\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryFileCredResp_OssType_RawValue(QryFileCredResp *message) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredResp_FieldNumber_OssType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryFileCredResp_OssType_RawValue(QryFileCredResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredResp_FieldNumber_OssType];
  GPBSetMessageRawEnumField(message, field, value);
}

void QryFileCredResp_ClearOssOfOneOfCase(QryFileCredResp *message) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - UploadLogStatusReq

@implementation UploadLogStatusReq

@dynamic msgId;
@dynamic logURL;
@dynamic state;

typedef struct UploadLogStatusReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t state;
  NSString *msgId;
  NSString *logURL;
} UploadLogStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = UploadLogStatusReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadLogStatusReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logURL",
        .dataTypeSpecific.clazz = Nil,
        .number = UploadLogStatusReq_FieldNumber_LogURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UploadLogStatusReq__storage_, logURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = UploadLogStatusReq_FieldNumber_State,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UploadLogStatusReq__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UploadLogStatusReq)
                                   messageName:@"UploadLogStatusReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadLogStatusReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\005\000\002\004!!\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QiNiuCredResp

@implementation QiNiuCredResp

@dynamic domain;
@dynamic token;

typedef struct QiNiuCredResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *domain;
  NSString *token;
} QiNiuCredResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domain",
        .dataTypeSpecific.clazz = Nil,
        .number = QiNiuCredResp_FieldNumber_Domain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QiNiuCredResp__storage_, domain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = QiNiuCredResp_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QiNiuCredResp__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QiNiuCredResp)
                                   messageName:@"QiNiuCredResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QiNiuCredResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreSignResp

@implementation PreSignResp

@dynamic URL;

typedef struct PreSignResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} PreSignResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = PreSignResp_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PreSignResp__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PreSignResp)
                                   messageName:@"PreSignResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PreSignResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001!!!\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineOfflineMsg

@implementation OnlineOfflineMsg

@dynamic type;
@dynamic userId;
@dynamic deviceId;
@dynamic platform;
@dynamic clientIp;
@dynamic sessionId;
@dynamic timestamp;
@dynamic connectionExt;

typedef struct OnlineOfflineMsg__storage_ {
  uint32_t _has_storage_[1];
  OnlineType type;
  NSString *userId;
  NSString *deviceId;
  NSString *platform;
  NSString *clientIp;
  NSString *sessionId;
  NSString *connectionExt;
  int64_t timestamp;
} OnlineOfflineMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = OnlineType_EnumDescriptor,
        .number = OnlineOfflineMsg_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_Platform,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_ClientIp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, clientIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_SessionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "connectionExt",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_ConnectionExt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, connectionExt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnlineOfflineMsg)
                                   messageName:@"OnlineOfflineMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineOfflineMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\002\006\000\003\010\000\005\010\000\006\t\000\010\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OnlineOfflineMsg_Type_RawValue(OnlineOfflineMsg *message) {
  GPBDescriptor *descriptor = [OnlineOfflineMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineOfflineMsg_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOnlineOfflineMsg_Type_RawValue(OnlineOfflineMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [OnlineOfflineMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineOfflineMsg_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - LogEntity

@implementation LogEntity

@dynamic logOfOneOfCase;
@dynamic connectionLog;
@dynamic disconnectionLog;
@dynamic sdkRequestLog;
@dynamic sdkResponseLog;
@dynamic businessLog;

typedef struct LogEntity__storage_ {
  uint32_t _has_storage_[2];
  ConnectionLog *connectionLog;
  DisconnectionLog *disconnectionLog;
  SdkRequestLog *sdkRequestLog;
  SdkResponseLog *sdkResponseLog;
  BusinessLog *businessLog;
} LogEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionLog",
        .dataTypeSpecific.clazz = GPBObjCClass(ConnectionLog),
        .number = LogEntity_FieldNumber_ConnectionLog,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntity__storage_, connectionLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disconnectionLog",
        .dataTypeSpecific.clazz = GPBObjCClass(DisconnectionLog),
        .number = LogEntity_FieldNumber_DisconnectionLog,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntity__storage_, disconnectionLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sdkRequestLog",
        .dataTypeSpecific.clazz = GPBObjCClass(SdkRequestLog),
        .number = LogEntity_FieldNumber_SdkRequestLog,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntity__storage_, sdkRequestLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sdkResponseLog",
        .dataTypeSpecific.clazz = GPBObjCClass(SdkResponseLog),
        .number = LogEntity_FieldNumber_SdkResponseLog,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntity__storage_, sdkResponseLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "businessLog",
        .dataTypeSpecific.clazz = GPBObjCClass(BusinessLog),
        .number = LogEntity_FieldNumber_BusinessLog,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntity__storage_, businessLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(LogEntity)
                                   messageName:@"LogEntity"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "logOf",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\013\r\000\014\020\000\r\r\000\016\016\000\017\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LogEntity_ClearLogOfOneOfCase(LogEntity *message) {
  GPBDescriptor *descriptor = [LogEntity descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ConnectionLog

@implementation ConnectionLog

@dynamic timestamp;
@dynamic serviceName;
@dynamic session;
@dynamic action;
@dynamic appKey;
@dynamic userId;
@dynamic platform;
@dynamic pushToken;
@dynamic pushChannel;
@dynamic clientIp;

typedef struct ConnectionLog__storage_ {
  uint32_t _has_storage_[1];
  NSString *timestamp;
  NSString *serviceName;
  NSString *session;
  NSString *action;
  NSString *appKey;
  NSString *userId;
  NSString *platform;
  NSString *pushToken;
  NSString *pushChannel;
  NSString *clientIp;
} ConnectionLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_ServiceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, serviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_Action,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_AppKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_UserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_Platform,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushToken",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_PushToken,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, pushToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushChannel",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_PushChannel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, pushChannel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.clazz = Nil,
        .number = ConnectionLog_FieldNumber_ClientIp,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ConnectionLog__storage_, clientIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ConnectionLog)
                                   messageName:@"ConnectionLog"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectionLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\005\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectionLog

@implementation DisconnectionLog

@dynamic timestamp;
@dynamic serviceName;
@dynamic session;
@dynamic action;
@dynamic appKey;
@dynamic userId;
@dynamic code;
@dynamic err;

typedef struct DisconnectionLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *timestamp;
  NSString *serviceName;
  NSString *session;
  NSString *action;
  NSString *appKey;
  NSString *userId;
  NSString *err;
} DisconnectionLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_ServiceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, serviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_Action,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_AppKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_UserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_Code,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "err",
        .dataTypeSpecific.clazz = Nil,
        .number = DisconnectionLog_FieldNumber_Err,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DisconnectionLog__storage_, err),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DisconnectionLog)
                                   messageName:@"DisconnectionLog"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectionLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\005\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SdkRequestLog

@implementation SdkRequestLog

@dynamic timestamp;
@dynamic serviceName;
@dynamic session;
@dynamic index;
@dynamic action;
@dynamic method;
@dynamic targetId;
@dynamic len;
@dynamic appKey;

typedef struct SdkRequestLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t len;
  NSString *timestamp;
  NSString *serviceName;
  NSString *session;
  NSString *action;
  NSString *method;
  NSString *targetId;
  NSString *appKey;
} SdkRequestLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_ServiceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, serviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Action,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Method,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_TargetId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "len",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_Len,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, len),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkRequestLog_FieldNumber_AppKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SdkRequestLog__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SdkRequestLog)
                                   messageName:@"SdkRequestLog"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SdkRequestLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\t\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SdkResponseLog

@implementation SdkResponseLog

@dynamic timestamp;
@dynamic serviceName;
@dynamic session;
@dynamic index;
@dynamic action;
@dynamic code;
@dynamic len;
@dynamic appKey;

typedef struct SdkResponseLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t code;
  uint32_t len;
  NSString *timestamp;
  NSString *serviceName;
  NSString *session;
  NSString *action;
  NSString *appKey;
} SdkResponseLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_ServiceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, serviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Action,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Code,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "len",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_Len,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, len),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SdkResponseLog_FieldNumber_AppKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SdkResponseLog__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SdkResponseLog)
                                   messageName:@"SdkResponseLog"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SdkResponseLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\t\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BusinessLog

@implementation BusinessLog

@dynamic timestamp;
@dynamic session;
@dynamic index;
@dynamic serviceName;
@dynamic method;
@dynamic message;
@dynamic appKey;

typedef struct BusinessLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSString *timestamp;
  NSString *session;
  NSString *serviceName;
  NSString *method;
  NSString *message;
  NSString *appKey;
} BusinessLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_Session,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_ServiceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, serviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_Method,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_Message,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = BusinessLog_FieldNumber_AppKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BusinessLog__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BusinessLog)
                                   messageName:@"BusinessLog"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BusinessLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\t\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushSwitch

@implementation PushSwitch

@dynamic switch_p;

typedef struct PushSwitch__storage_ {
  uint32_t _has_storage_[1];
  int32_t switch_p;
} PushSwitch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "switch_p",
        .dataTypeSpecific.clazz = Nil,
        .number = PushSwitch_FieldNumber_Switch_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushSwitch__storage_, switch_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PushSwitch)
                                   messageName:@"PushSwitch"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushSwitch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChrmEvent

@implementation ChrmEvent

@dynamic eventType;
@dynamic chatId;
@dynamic userId;
@dynamic eventTime;

typedef struct ChrmEvent__storage_ {
  uint32_t _has_storage_[1];
  ChrmEventType eventType;
  NSString *chatId;
  NSString *userId;
  int64_t eventTime;
} ChrmEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.enumDescFunc = ChrmEventType_EnumDescriptor,
        .number = ChrmEvent_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_ChatId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChrmEvent_FieldNumber_EventTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChrmEvent__storage_, eventTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChrmEvent)
                                   messageName:@"ChrmEvent"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChrmEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\t\000\002\006\000\003\006\000\004\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChrmEvent_EventType_RawValue(ChrmEvent *message) {
  GPBDescriptor *descriptor = [ChrmEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmEvent_FieldNumber_EventType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChrmEvent_EventType_RawValue(ChrmEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [ChrmEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChrmEvent_FieldNumber_EventType];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
